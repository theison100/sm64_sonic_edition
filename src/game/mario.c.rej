diff a/src/game/mario.c b/src/game/mario.c	(rejected hunks)
@@ -2,6 +2,7 @@
 
 #include "sm64.h"
 #include "area.h"
+#include "audio/data.h"
 #include "audio/external.h"
 #include "behavior_actions.h"
 #include "behavior_data.h"
@@ -25,6 +26,7 @@
 #include "mario_misc.h"
 #include "mario_step.h"
 #include "memory.h"
+#include "ingame_menu.h"
 #include "object_fields.h"
 #include "object_helpers.h"
 #include "object_list_processor.h"
@@ -32,6 +34,7 @@
 #include "save_file.h"
 #include "sound_init.h"
 #include "rumble_init.h"
+#include "seq_ids.h"
 
 u32 unused80339F10;
 s8 filler80339F1C[20];
@@ -40,10 +43,14 @@ s8 filler80339F1C[20];
  *                    ANIMATIONS                  *
  **************************************************/
 
+
+
+
 /**
  * Checks if Mario's animation has reached its end point.
  */
 s32 is_anim_at_end(struct MarioState *m) {
+
     struct Object *o = m->marioObj;
 
     return (o->header.gfx.animInfo.animFrame + 1) == o->header.gfx.animInfo.curAnim->loopEnd;
@@ -238,7 +245,7 @@ s16 return_mario_anim_y_translation(struct MarioState *m) {
  * Plays a sound if if Mario doesn't have the flag being checked.
  */
 void play_sound_if_no_flag(struct MarioState *m, u32 soundBits, u32 flags) {
-    if (!(m->flags & flags)) {
+    if ((m->flags & flags) == 0) {
         play_sound(soundBits, m->marioObj->header.gfx.cameraToObject);
         m->flags |= flags;
     }
@@ -255,11 +262,12 @@ void play_mario_jump_sound(struct MarioState *m) {
                        m->marioObj->header.gfx.cameraToObject);
         } else {
 #endif
-            play_sound(SOUND_MARIO_YAH_WAH_HOO + ((gAudioRandom % 3) << 16),
+            play_sound(SOUND_MARIO_TWIRL_BOUNCE,
                        m->marioObj->header.gfx.cameraToObject);
 #ifndef VERSION_JP
         }
 #endif
+
         m->flags |= MARIO_MARIO_SOUND_PLAYED;
     }
 }
@@ -281,6 +289,7 @@ void play_sound_and_spawn_particles(struct MarioState *m, u32 soundBits, u32 wav
             m->particleFlags |= PARTICLE_SHALLOW_WATER_SPLASH;
         } else {
             m->particleFlags |= PARTICLE_SHALLOW_WATER_WAVE;
+			spawn_object(m, MODEL_WAVE_TRAIL, bhvObjectWaveTrail);
         }
     } else {
         if (m->terrainSoundAddend == (SOUND_TERRAIN_SAND << 16)) {
@@ -302,7 +311,7 @@ void play_sound_and_spawn_particles(struct MarioState *m, u32 soundBits, u32 wav
  * Plays an environmental sound if one has not been played since the last action change.
  */
 void play_mario_action_sound(struct MarioState *m, u32 soundBits, u32 waveParticleType) {
-    if (!(m->flags & MARIO_ACTION_SOUND_PLAYED)) {
+    if ((m->flags & MARIO_ACTION_SOUND_PLAYED) == 0) {
         play_sound_and_spawn_particles(m, soundBits, waveParticleType);
         m->flags |= MARIO_ACTION_SOUND_PLAYED;
     }
@@ -322,8 +331,8 @@ void play_mario_landing_sound(struct MarioState *m, u32 soundBits) {
  * played once per action.
  */
 void play_mario_landing_sound_once(struct MarioState *m, u32 soundBits) {
-    play_mario_action_sound(
-        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_LANDING : soundBits, 1);
+    play_mario_action_sound(m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_LANDING : soundBits,
+                            1);
 }
 
 /**
@@ -349,8 +358,9 @@ void play_mario_heavy_landing_sound_once(struct MarioState *m, u32 soundBits) {
  */
 void play_mario_sound(struct MarioState *m, s32 actionSound, s32 marioSound) {
     if (actionSound == SOUND_ACTION_TERRAIN_JUMP) {
-        play_mario_action_sound(m, (m->flags & MARIO_METAL_CAP) ? (s32) SOUND_ACTION_METAL_JUMP
-                                                                : (s32) SOUND_ACTION_TERRAIN_JUMP, 1);
+        play_mario_action_sound(
+                m, (m->flags & MARIO_METAL_CAP) ? (s32)SOUND_ACTION_METAL_JUMP
+                                                : (s32)SOUND_ACTION_TERRAIN_JUMP, 1);
     } else {
         play_sound_if_no_flag(m, actionSound, MARIO_ACTION_SOUND_PLAYED);
     }
@@ -379,6 +389,8 @@ void mario_set_forward_vel(struct MarioState *m, f32 forwardVel) {
 
     m->vel[0] = (f32) m->slideVelX;
     m->vel[2] = (f32) m->slideVelZ;
+
+	
 }
 
 /**
@@ -396,7 +408,7 @@ s32 mario_get_floor_class(struct MarioState *m) {
         floorClass = SURFACE_CLASS_DEFAULT;
     }
 
-    if (m->floor != NULL) {
+    if (m->floor) {
         switch (m->floor->type) {
             case SURFACE_NOT_SLIPPERY:
             case SURFACE_HARD_NOT_SLIPPERY:
@@ -462,10 +474,10 @@ u32 mario_get_terrain_sound_addend(struct MarioState *m) {
     s32 ret = SOUND_TERRAIN_DEFAULT << 16;
     s32 floorType;
 
-    if (m->floor != NULL) {
+    if (m->floor) {
         floorType = m->floor->type;
 
-        if ((gCurrLevelNum != LEVEL_LLL) && (m->floorHeight < (m->waterLevel - 10))) {
+        if ((gCurrLevelNum != LEVEL_LLL) && (m->floorHeight <= (m->waterLevel+1))) {
             // Water terrain sound, excluding LLL since it uses water in the volcano.
             ret = SOUND_TERRAIN_WATER << 16;
         } else if (SURFACE_IS_QUICKSAND(floorType)) {
@@ -509,6 +521,10 @@ u32 mario_get_terrain_sound_addend(struct MarioState *m) {
             }
 
             ret = sTerrainSounds[terrainType][floorSoundType] << 16;
+
+              if (m->floor->type == SURFACE_BURNING && (m->flags & MARIO_IS_SUPER)) {
+                ret = SOUND_TERRAIN_WATER << 16;
+            }
         }
     }
 
@@ -607,25 +623,26 @@ s32 mario_floor_is_slope(struct MarioState *m) {
     f32 normY;
 
     if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE
-        && m->floor->normal.y < 0.9998477f) { // ~cos(1 deg)
+        && m->floor->normal.y < 0.9998477f //~cos(1 deg)
+    ) {
         return TRUE;
     }
 
     switch (mario_get_floor_class(m)) {
         case SURFACE_VERY_SLIPPERY:
-            normY = 0.9961947f; // ~cos(5 deg)
+            normY = 0.9961947f; //~cos(5 deg)
             break;
 
         case SURFACE_SLIPPERY:
-            normY = 0.9848077f; // ~cos(10 deg)
+            normY = 0.9848077f; //~cos(10 deg)
             break;
 
         default:
-            normY = 0.9659258f; // ~cos(15 deg)
+            normY = 0.9659258f; //~cos(15 deg)
             break;
 
         case SURFACE_NOT_SLIPPERY:
-            normY = 0.9396926f; // ~cos(20 deg)
+            normY = 0.9396926f; //~cos(20 deg)
             break;
     }
 
@@ -646,19 +663,19 @@ s32 mario_floor_is_steep(struct MarioState *m) {
     if (!mario_facing_downhill(m, FALSE)) {
         switch (mario_get_floor_class(m)) {
             case SURFACE_VERY_SLIPPERY:
-                normY = 0.9659258f; // ~cos(15 deg)
+                normY = 0.9659258f; //~cos(15 deg)
                 break;
 
             case SURFACE_SLIPPERY:
-                normY = 0.9396926f; // ~cos(20 deg)
+                normY = 0.9396926f; //~cos(20 deg)
                 break;
 
             default:
-                normY = 0.8660254f; // ~cos(30 deg)
+                normY = 0.8660254f; //~cos(30 deg)
                 break;
 
             case SURFACE_NOT_SLIPPERY:
-                normY = 0.8660254f; // ~cos(30 deg)
+                normY = 0.8660254f; //~cos(30 deg)
                 break;
         }
 
@@ -754,7 +771,7 @@ void set_steep_jump_action(struct MarioState *m) {
         m->faceAngle[1] = atan2s(x, y) + angleTemp;
     }
 
-    drop_and_set_mario_action(m, ACT_STEEP_JUMP, 0);
+    drop_and_set_mario_action(m, ACT_JUMP, 0);
 }
 
 /**
@@ -773,24 +790,32 @@ static void set_mario_y_vel_based_on_fspeed(struct MarioState *m, f32 initialVel
 /**
  * Transitions for a variety of airborne actions.
  */
+
+
+
+
 static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actionArg) {
     f32 fowardVel;
 
-    if ((m->squishTimer != 0 || m->quicksandDepth >= 1.0f)
-        && (action == ACT_DOUBLE_JUMP || action == ACT_TWIRLING)) {
-        action = ACT_JUMP;
+    if (m->squishTimer != 0 || m->quicksandDepth >= 1.0f) {
+        if (action == ACT_DOUBLE_JUMP || action == ACT_TWIRLING) {
+            action = ACT_JUMP;
+
+        }
     }
 
     switch (action) {
         case ACT_DOUBLE_JUMP:
-            set_mario_y_vel_based_on_fspeed(m, 52.0f, 0.25f);
-            m->forwardVel *= 0.8f;
+			m->forwardVel = 40.0f;
+            set_mario_y_vel_based_on_fspeed(m, 40.0f, 0.25f);
+
+                
             break;
 
         case ACT_BACKFLIP:
             m->marioObj->header.gfx.animInfo.animID = -1;
-            m->forwardVel = -16.0f;
-            set_mario_y_vel_based_on_fspeed(m, 62.0f, 0.0f);
+            m->forwardVel = -0.0f;
+            set_mario_y_vel_based_on_fspeed(m, 70.0f, 0.0f);
             break;
 
         case ACT_TRIPLE_JUMP:
@@ -821,8 +846,36 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
         case ACT_JUMP:
         case ACT_HOLD_JUMP:
             m->marioObj->header.gfx.animInfo.animID = -1;
-            set_mario_y_vel_based_on_fspeed(m, 42.0f, 0.25f);
-            m->forwardVel *= 0.8f;
+			
+			if (m->forwardVel > 140.0f)
+			{
+				m->forwardVel = 140.0f;
+			}
+			if (m->forwardVel <= 10.0f)
+			{
+
+				m->forwardVel *= 0.5f;
+				if (!(m->flags & MARIO_IS_SUPER))
+				{
+					set_mario_y_vel_based_on_fspeed(m, 52.0f, 0.25f);
+				}
+				else
+				{
+					set_mario_y_vel_based_on_fspeed(m, 59.0f, 0.25f);
+				}
+			}
+			else
+			{
+				m->forwardVel *= 0.4f;
+				if (!(m->flags & MARIO_IS_SUPER))
+				{
+					set_mario_y_vel_based_on_fspeed(m, 40.0f, 0.25f);
+				}
+				else
+				{
+					set_mario_y_vel_based_on_fspeed(m, 49.0f, 0.25f);
+				}
+			}
             break;
 
         case ACT_WALL_KICK_AIR:
@@ -850,14 +903,168 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
             m->vel[1] = 84.0f;
             if (actionArg == 0) {
                 m->forwardVel = 0.0f;
+
             }
             break;
 
         case ACT_DIVE:
-            if ((fowardVel = m->forwardVel + 15.0f) > 48.0f) {
-                fowardVel = 48.0f;
-            }
+			if (m->homingObj != NULL)
+			{
+				if (m->homingObj == m->usedObj)
+				{
+					m->homingObj = NULL;
+                }
+                else
+                {
+                   
+                }
+
+
+			}
+            /*
+            if ((fowardVel = m->forwardVel + 15.0f) > 28.0f) {
+				m->homingObj = NULL;
+				m->actionTimer = 0;
+
+				//m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] - 25;
+				
+
+					if (cur_obj_dist_to_nearest_object_with_behavior(bhvJumpingBox) < 800.0f)
+					{
+
+						m->homingObj = cur_obj_nearest_object_with_behavior(bhvJumpingBox);
+					}
+
+					if (cur_obj_dist_to_nearest_object_with_behavior(bhvSnufit) < 800.0f)
+					{
+
+						m->homingObj = cur_obj_nearest_object_with_behavior(bhvSnufit);
+					}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvSmallBully) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvSmallBully);
+				}     
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvBobomb) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvBobomb);
+				}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvGoomba) < 800.0f)
+				{
+
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvGoomba);
+				}
+
+		
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvBigBully) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvBigBully);
+				}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvPiranhaPlant) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvPiranhaPlant);
+				}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvScuttlebug) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvScuttlebug);
+				}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvMoneybag) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvMoneybag);
+				}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvKoopa) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvKoopa);
+				}
+
+				
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvFlyGuy) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvFlyGuy);
+				}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvEnemyLakitu) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvEnemyLakitu);
+				}
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvMontyMole) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvMontyMole);
+				}
+				
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvFirePiranhaPlant) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvFirePiranhaPlant);
+				}
+				
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvSkeeter) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvSkeeter);
+				}
+				
+				
+
+
+					if (cur_obj_dist_to_nearest_object_with_behavior(bhvSpindrift) < 800.0f)
+					{
+
+						m->homingObj = cur_obj_nearest_object_with_behavior(bhvSpindrift);
+					}
+
+
+				if (cur_obj_dist_to_nearest_object_with_behavior(bhvBigChillBully) < 800.0f)
+				{
+
+					m->homingObj = cur_obj_nearest_object_with_behavior(bhvBigChillBully);
+				}
+                //if (m->interactObj == NULL)
+                if (m->homingObj != NULL)
+                {
+                    spawn_object(m->homingObj, MODEL_GOOMBA, bhvReticle);
+                    if (m->homingObj->oPosY > m->pos[1])
+                    {
+                        m->homingObj = NULL;
+                    }
+                }
+				if (m->homingObj == NULL)
+				{
+					fowardVel = 48.0f;
+					
+				
             mario_set_forward_vel(m, fowardVel);
+                }
+            }
+            */
+
+if (m->homingObj == NULL)
+{
+    fowardVel = 48.0f;
+
+
+    mario_set_forward_vel(m, fowardVel);
+}
             break;
 
         case ACT_LONG_JUMP:
@@ -873,12 +1080,12 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
             break;
 
         case ACT_SLIDE_KICK:
-            m->vel[1] = 12.0f;
-            if (m->forwardVel < 32.0f) {
-                m->forwardVel = 32.0f;
-            }
+           // m->vel[1] = 1.0f;
+            m->forwardVel *= 1.5f;
+           
             break;
 
+
         case ACT_JUMP_KICK:
             m->vel[1] = 20.0f;
             break;
@@ -896,19 +1103,36 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
 static u32 set_mario_action_moving(struct MarioState *m, u32 action, UNUSED u32 actionArg) {
     s16 floorClass = mario_get_floor_class(m);
     f32 forwardVel = m->forwardVel;
-    f32 mag = min(m->intendedMag, 8.0f);
+    f32 mag = min(m->intendedMag, 10.0f);
+	f32 val04;
+	val04 = m->intendedMag > m->forwardVel ? m->intendedMag : m->forwardVel;
 
     switch (action) {
         case ACT_WALKING:
             if (floorClass != SURFACE_CLASS_VERY_SLIPPERY) {
-                if (0.0f <= forwardVel && forwardVel < mag) {
-                    m->forwardVel = mag;
+                if (0.0f <= forwardVel) {
+					if (m->forwardVel <= mag)
+					{
+						m->forwardVel = mag;
+					}
+					
                 }
             }
 
             m->marioObj->oMarioWalkingPitch = 0;
             break;
 
+        case ACT_SLIDE_KICK:
+
+            m->forwardVel *= 10.0f;
+            break;
+
+        case ACT_SLIDE_KICK_SLIDE:
+
+            m->forwardVel *= 10.0f;
+            break;
+
+
         case ACT_HOLD_WALKING:
             if (0.0f <= forwardVel && forwardVel < mag / 2.0f) {
                 m->forwardVel = mag / 2.0f;
@@ -939,9 +1163,14 @@ static u32 set_mario_action_moving(struct MarioState *m, u32 action, UNUSED u32
  * Transition for certain submerged actions, which is actually just the metal jump actions.
  */
 static u32 set_mario_action_submerged(struct MarioState *m, u32 action, UNUSED u32 actionArg) {
-    if (action == ACT_METAL_WATER_JUMP || action == ACT_HOLD_METAL_WATER_JUMP) {
-        m->vel[1] = 32.0f;
-    }
+
+	if (action == ACT_METAL_WATER_JUMP || action == ACT_HOLD_METAL_WATER_JUMP) {
+
+			m->vel[1] = 32.0f;
+
+
+	}
+
 
     return action;
 }
@@ -1027,42 +1256,15 @@ s32 set_jump_from_landing(struct MarioState *m) {
     if (mario_floor_is_steep(m)) {
         set_steep_jump_action(m);
     } else {
-        if ((m->doubleJumpTimer == 0) || (m->squishTimer != 0)) {
+        if ((m->doubleJumpTimer == 0) ) {
             set_mario_action(m, ACT_JUMP, 0);
         } else {
-            switch (m->prevAction) {
-                case ACT_JUMP_LAND:
-                    set_mario_action(m, ACT_DOUBLE_JUMP, 0);
-                    break;
-
-                case ACT_FREEFALL_LAND:
-                    set_mario_action(m, ACT_DOUBLE_JUMP, 0);
-                    break;
-
-                case ACT_SIDE_FLIP_LAND_STOP:
-                    set_mario_action(m, ACT_DOUBLE_JUMP, 0);
-                    break;
-
-                case ACT_DOUBLE_JUMP_LAND:
-                    // If Mario has a wing cap, he ignores the typical speed
-                    // requirement for a triple jump.
-                    if (m->flags & MARIO_WING_CAP) {
-                        set_mario_action(m, ACT_FLYING_TRIPLE_JUMP, 0);
-                    } else if (m->forwardVel > 20.0f) {
-                        set_mario_action(m, ACT_TRIPLE_JUMP, 0);
-                    } else {
-                        set_mario_action(m, ACT_JUMP, 0);
-                    }
-                    break;
-
-                default:
-                    set_mario_action(m, ACT_JUMP, 0);
-                    break;
-            }
+			set_mario_action(m, ACT_JUMP, 0);
+           
         }
     }
 
-    m->doubleJumpTimer = 0;
+
 
     return TRUE;
 }
@@ -1105,9 +1307,42 @@ s32 drop_and_set_mario_action(struct MarioState *m, u32 action, u32 actionArg) {
  * Increment Mario's hurt counter and set a new action.
  */
 s32 hurt_and_set_mario_action(struct MarioState *m, u32 action, u32 actionArg, s16 hurtCounter) {
-    m->hurtCounter = hurtCounter;
+    //sonic bowser stomp
+    if (!(m->flags & MARIO_IS_SUPER))
+    {
+        if (gDialogHealthSystem != SONIC_HEALTH)
+        {
+            m->hurtCounter = hurtCounter;
+        }
+        else
+        {
+            m->hurtCounter = 0;
+            if (gMarioState->numCoins > 0)
+            {
+
+                if (gMarioState->numCoins >= 50) {
+                    play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                    obj_spawn_yellow_coins(m->marioObj, 50);
+                    gMarioState->numCoins = 0;
+                    gHudDisplay.coins = 0;
+                }
+                else {
+                    play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                    obj_spawn_yellow_coins(m->marioObj, gMarioState->numCoins);
+                    gMarioState->numCoins = 0;
+                    gHudDisplay.coins = 0;
+                }
+            }
+            else
+            {
 
-    return set_mario_action(m, action, actionArg);
+                m->health = 0xFF;
+
+            }
+        }
+    }
+        return set_mario_action(m, action, actionArg);
+    
 }
 
 /**
@@ -1115,6 +1350,7 @@ s32 hurt_and_set_mario_action(struct MarioState *m, u32 action, u32 actionArg, s
  * actions. A common variant of the below function.
  */
 s32 check_common_action_exits(struct MarioState *m) {
+
     if (m->input & INPUT_A_PRESSED) {
         return set_mario_action(m, ACT_JUMP, 0);
     }
@@ -1172,8 +1408,8 @@ s32 transition_submerged_to_walking(struct MarioState *m) {
  * non-submerged action. This also applies the water surface camera preset.
  */
 s32 set_water_plunge_action(struct MarioState *m) {
-    m->forwardVel = m->forwardVel / 4.0f;
-    m->vel[1] = m->vel[1] / 2.0f;
+    m->forwardVel = m->forwardVel / 4.1f;
+    m->vel[1] = m->vel[1] / 2.1f;
 
     m->pos[1] = m->waterLevel - 100;
 
@@ -1181,7 +1417,7 @@ s32 set_water_plunge_action(struct MarioState *m) {
 
     vec3s_set(m->angleVel, 0, 0, 0);
 
-    if (!(m->action & ACT_FLAG_DIVING)) {
+    if ((m->action & ACT_FLAG_DIVING) == 0) {
         m->faceAngle[0] = 0;
     }
 
@@ -1205,8 +1441,12 @@ u8 sSquishScaleOverTime[16] = { 0x46, 0x32, 0x32, 0x3C, 0x46, 0x50, 0x50, 0x3C,
 void squish_mario_model(struct MarioState *m) {
     if (m->squishTimer != 0xFF) {
         // If no longer squished, scale back to default.
+        // Also handles the Tiny Mario and Huge Mario cheats.
         if (m->squishTimer == 0) {
-            vec3f_set(m->marioObj->header.gfx.scale, 1.0f, 1.0f, 1.0f);
+            
+                vec3f_set(m->marioObj->header.gfx.scale, 1.0f, 1.0f, 1.0f);
+            
+            
         }
         // If timer is less than 16, rubber-band Mario's size scale up and down.
         else if (m->squishTimer <= 16) {
@@ -1282,7 +1522,7 @@ void update_mario_button_inputs(struct MarioState *m) {
 
     if (m->input & INPUT_B_PRESSED) {
         m->framesSinceB = 0;
-    } else if (m->framesSinceB < 0xFF) {
+    } else if (m->framesSinceB < 0xff) {
         m->framesSinceB += 1;
     }
 }
@@ -1292,16 +1532,37 @@ void update_mario_button_inputs(struct MarioState *m) {
  */
 void update_mario_joystick_inputs(struct MarioState *m) {
     struct Controller *controller = m->controller;
-    f32 mag = ((controller->stickMag / 64.0f) * (controller->stickMag / 64.0f)) * 64.0f;
+    f32 mag = ((controller->stickMag / 64.0f) * (controller->stickMag / 64.0f)) * 140.0f;
 
     if (m->squishTimer == 0) {
-        m->intendedMag = mag / 2.0f;
+		if (m->flags & MARIO_IS_SUPER)
+		{
+			m->intendedMag = mag / 1.7f;
+		}
+		else
+		{
+			m->intendedMag = mag / 2.0f;
+		}
     } else {
-        m->intendedMag = mag / 8.0f;
+		if (m->flags & MARIO_IS_SUPER)
+		{
+			m->intendedMag = mag / 2.7f;
+		}
+		else
+		{
+			m->intendedMag = mag / 3.0f;
+		}
     }
 
     if (m->intendedMag > 0.0f) {
+#ifndef BETTERCAMERA
         m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
+#else
+        if (gLakituState.mode != CAMERA_MODE_NEWCAM)
+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
+        else
+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX)-newcam_yaw+0x4000;
+#endif
         m->input |= INPUT_NONZERO_ANALOG;
     } else {
         m->intendedYaw = m->faceAngle[1];
@@ -1333,7 +1594,7 @@ void update_mario_geometry_inputs(struct MarioState *m) {
     gasLevel = find_poison_gas_level(m->pos[0], m->pos[2]);
     m->waterLevel = find_water_level(m->pos[0], m->pos[2]);
 
-    if (m->floor != NULL) {
+    if (m->floor) {
         m->floorAngle = atan2s(m->floor->normal.z, m->floor->normal.x);
         m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
 
@@ -1381,6 +1642,10 @@ void update_mario_inputs(struct MarioState *m) {
     update_mario_geometry_inputs(m);
 
     debug_print_speed_action_normal(m);
+    
+    /* Moonjump cheat */
+
+    /*End of moonjump cheat */
 
     if (gCameraMovementFlags & CAM_MOVE_C_UP_MODE) {
         if (m->action & ACT_FLAG_ALLOW_FIRST_PERSON) {
@@ -1407,9 +1672,7 @@ void update_mario_inputs(struct MarioState *m) {
         m->wallKickTimer--;
     }
 
-    if (m->doubleJumpTimer > 0) {
-        m->doubleJumpTimer--;
-    }
+  
 }
 
 /**
@@ -1423,7 +1686,7 @@ void set_submerged_cam_preset_and_spawn_bubbles(struct MarioState *m) {
         heightBelowWater = (f32)(m->waterLevel - 80) - m->pos[1];
         camPreset = m->area->camera->mode;
 
-        if (m->action & ACT_FLAG_METAL_WATER) {
+        if ((m->action & ACT_FLAG_METAL_WATER)) {
             if (camPreset != CAMERA_MODE_CLOSE) {
                 set_camera_mode(m->area->camera, CAMERA_MODE_CLOSE, 1);
             }
@@ -1438,7 +1701,7 @@ void set_submerged_cam_preset_and_spawn_bubbles(struct MarioState *m) {
 
             // As long as Mario isn't drowning or at the top
             // of the water with his head out, spawn bubbles.
-            if (!(m->action & ACT_FLAG_INTANGIBLE)) {
+            if ((m->action & ACT_FLAG_INTANGIBLE) == 0) {
                 if ((m->pos[1] < (f32)(m->waterLevel - 160)) || (m->faceAngle[0] < -0x800)) {
                     m->particleFlags |= PARTICLE_BUBBLE;
                 }
@@ -1450,30 +1713,648 @@ void set_submerged_cam_preset_and_spawn_bubbles(struct MarioState *m) {
 /**
  * Both increments and decrements Mario's HP.
  */
-void update_mario_health(struct MarioState *m) {
-    s32 terrainIsSnow;
+s32 update_mario_health(struct MarioState *m) {
+	s32 terrainIsSnow;
+	s32 gasTimer;
+	s32 coinTimer;
+	s32 allowTransform;
+	u8 starbob = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_BOB - 1);
+	u8 starbbh = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_BBH - 1);
+	u8 starccm = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_CCM - 1);
+	u8 starhmc = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_HMC - 1);
+	u8 starssl = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_SSL - 1);
+	u8 starsl = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_SL - 1);
+	u8 starwdw = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_WDW - 1);
+	u8 starjrb = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_JRB - 1);
+	u8 starthi = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_THI - 1);
+	u8 starttc = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_TTC - 1);
+	u8 starrr = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_RR - 1);
+	u8 starlll = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_LLL - 1);
+	u8 starddd = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_DDD - 1);
+	u8 starwf = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_WF - 1);
+	u8 starttm = save_file_get_star_flags(gCurrSaveFileNum - 1, COURSE_TTM - 1);
+
+  //  gMarioState->flags &= ~MARIO_IS_SHADOW;
+    //update homing
+
+
+    if (m->action == ACT_JUMP || m->action == ACT_DOUBLE_JUMP || m->action == ACT_STEEP_JUMP || m->action == ACT_SIDE_FLIP) {
+
+        m->homingObj = NULL;
+
+            //m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] - 25;
+      
+
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvJumpingBox) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvJumpingBox);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvSnufit) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvSnufit);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvSmallBully) < 800.0f)
+            {
+                //gMarioState->numCoins = 1;
+               // gHudDisplay.coins = 1;
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvSmallBully);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvBobomb) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvBobomb);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvGoomba) < 800.0f)
+            {
+
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvGoomba);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvBigBully) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvBigBully);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvBigBullyWithMinions) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvBigBullyWithMinions);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvPiranhaPlant) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvPiranhaPlant);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvScuttlebug) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvScuttlebug);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvKlepto) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvKlepto);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvMoneybag) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvMoneybag);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvKoopa) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvKoopa);
+              
+                  
+                
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvFlyGuy) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvFlyGuy);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvEnemyLakitu) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvEnemyLakitu);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvMontyMole) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvMontyMole);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvFirePiranhaPlant) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvFirePiranhaPlant);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvSkeeter) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvSkeeter);
+            }
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvSpindrift) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvSpindrift);
+            }
+
+
+            if (cur_obj_dist_to_nearest_object_with_behavior(bhvBigChillBully) < 800.0f)
+            {
+
+                m->homingObj = cur_obj_nearest_object_with_behavior(bhvBigChillBully);
+            }
+            //if (m->interactObj == NULL)
+            if (m->homingObj != NULL)
+            {
+                //if (m->homingObj->oPosY > m->pos[1] - 10.0f || m->homingObj->oDistanceToMario > 800.0f) BULLY
+                if (m->homingObj->oPosY > m->pos[1] - 10.0f)
+                {
+                    m->homingObj = NULL;
+                }
+                else
+                {
+                    if (count_objects_with_behavior(bhvReticle) < 1)
+                    {
+                        spawn_object(m->homingObj, MODEL_RETICLE, bhvReticle);
+                       
+                    }
+
+                }
+            }
+            else
+            {
+                m->homingObj = NULL;
+            }
+
+            
+        
+        
+
+
+
+    }
+
+
+	m->coinstartotal = ((starbob & (1 << 6)) + (starbbh & (1 << 6)) + (starccm & (1 << 6)) + (starhmc & (1 << 6)) + (starssl & (1 << 6)) + (starsl & (1 << 6)) + (starwdw & (1 << 6)) + (starjrb & (1 << 6)) + (starthi & (1 << 6)) + (starttc & (1 << 6)) + (starrr & (1 << 6)) + (starlll & (1 << 6)) + (starddd & (1 << 6)) + (starwf & (1 << 6)) + (starttm & (1 << 6))) / 64; //+ starbbh + starccm + starhmc + starssl + starsl + starwdw + starjrb + starthi + starttc + starrr + starlll + starddd + starwf + starttm;
+
+	if (cur_obj_dist_to_nearest_object_with_behavior(bhv_jet_stream_water_ring_loop) < 800.0f)
+	{
+		m->drownTimer = 0;
+	}
+
+	if (cur_obj_dist_to_nearest_object_with_behavior(bhv_manta_ray_water_ring_init) < 800.0f)
+	{
+		m->drownTimer = 0;
+	}
+
+
+	//u16 capMusic = 0;
+	//gsDPSetEnvColor(100, 100, 100, 100);
+	m->coinTimer++;
+	//gMarioState->numLives = m->area->camera->defMode;
+	if (m->flags & MARIO_IS_SUPER)
+	{
+     //   spawn_object(m, MODEL_EMERALD_CIRCLE, bhvEmeraldCircle);
+		m->particleFlags |= PARTICLE_SPARKLES;
+
+		if (gCurrLevelNum != LEVEL_CASTLE_GROUNDS && gCurrLevelNum != LEVEL_CASTLE && gCurrLevelNum != LEVEL_CASTLE_COURTYARD)
+		{
+			if (gMarioState->numCoins > 0)
+			{
+
+
+				if (m->coinTimer >= 60)
+				{
+
+					gMarioState->numCoins += -1;
+					gHudDisplay.coins += -1;
+					m->coinTimer = 0;
+
+
+				}
+
+			}
+			else
+			{
+				if (m->capTimer <= 0) {
+
+					stop_cap_music();
+
+				}
+
+                if (m->flags & ( MARIO_VANISH_CAP | MARIO_WING_CAP))
+                {
+                    play_cap_music(SEQUENCE_ARGS(4, SEQ_EVENT_POWERUP));
+                }
+
+                if (m->flags & MARIO_METAL_CAP)
+                {
+                    play_cap_music(SEQUENCE_ARGS(4, SEQ_EVENT_METAL_CAP));
+                }
+
+				m->flags &= ~MARIO_IS_SUPER;
+			}
+		}
+
+
+
+
+		if (m->action != ACT_DIVE)
+		{
+			if (m->action != ACT_SPINDASH)
+			{
+				
+				//gDPSetEnvColor(gDisplayListHead++, 255, 100, 255, 255);
+				cur_obj_set_model(MODEL_SUPER_SONIC);
+			}
+		}
+		//capMusic = SEQUENCE_ARGS(4, SEQ_EVENT_POWERUP);
+
+	
+
+		//if (capMusic == 0) {
+			//play_cap_music(SEQUENCE_ARGS(4, SEQ_EVENT_POWERUP));
+			//capMusic = 1;
+		//}
+	}
+
+
+
+	if (m->action == ACT_JUMP)
+	{
+
+	}
+
+
+	if (allowTransform != 1)
+	{
+		allowTransform = 0;
+	}
+
+	//m->particleFlags |= PARTICLE_SPARKLES;
+
+
+
+	if ((m->input & INPUT_A_PRESSED) && (m->action == ACT_GROUND_POUND))
+	{
+            if ((gMarioState->numCoins >= 50) || (gCurrLevelNum == LEVEL_CASTLE_GROUNDS || gCurrLevelNum == LEVEL_CASTLE_COURTYARD || gCurrLevelNum == LEVEL_CASTLE)) {
+                if (count_objects_with_behavior(bhvWigglerHead) < 1) {
+                    
+                    allowTransform = 1.0;
+                }
+            }
+		//m->forwardVel += 50.0f;	
+		//&& !(m->flags & MARIO_IS_SUPER)
+	}
+
+	//if (stars & (1 << 6))
+	//{
+		//gMarioState->numLives = m->coinstartotal;
+	//}
+	//else
+	//{
+
+		//gMarioState->numCoins = 99;
+		//gHudDisplay.coins = 99;
+	//}
+
+         if (m->input & INPUT_A_PRESSED) {
+
+            //  gMarioState->numCoins = 99;
+            //  gHudDisplay.coins = 99;
+        }
+
+	// change coinstar to 7y
+	if (allowTransform == 1 && !(m->flags & MARIO_IS_SUPER) && m->coinstartotal >= 7)
+	{
+        spawn_object_relative(0, 0, 0, 0, m->marioObj, MODEL_EMERALD_CIRCLE, bhvEmeraldCircle);
+           return set_mario_action(m, ACT_TRANSFORM, 0);
+
+        
+
+
+		//m->forwardVel += 50.0f;
+		//play_cap_music(capMusic);
+		m->coinTimer = 0;
+		
+
+	}
+
+
+	if (gDialogHealthSystem == SONIC_HEALTH)
+	{
+		if (gMarioState->numCoins == 0)
+		{
+			if (m->health > 0x100)
+			{
+				//m->health = 0x100;
+			}
+		}
+		//obj_spawn_yellow_coins(m->marioObj, 5);
+		//play_sound(SOUND_MOVING_ALMOST_DROWNING, gGlobalSoundSource);
+	}
+	if (m->action == ACT_DIVE && m->interactObj != NULL)
+	{
+		m->marioObj->header.gfx.animInfo.animAccel = 0x30000;
+			//m->faceAngle[1] = mario_obj_angle_to_object(m, m->interactObj);
+
+		
+	}
+
+	if (m->action != ACT_JUMP)
+	{
+		if (m->action != ACT_SPINDASH)
+		{
+			if (m->action != ACT_DIVE)
+			{
+				if (m->action != ACT_GROUND_POUND)
+				{
+					if (!(m->flags & MARIO_IS_SUPER))
+					{
+						cur_obj_set_model(MODEL_MARIO);
+					}
+
+				}
+			}
+		}
+	}
+
+    if (m->action == ACT_METAL_WATER_JUMP)
+    {
+
+        if (m->vel[1] >= 1.0f)
+        { 
+        if (!(m->flags & MARIO_IS_SUPER))
+        {
+            cur_obj_set_model(MODEL_SONIC_BALL);
+        }
+        else
+        {
+            cur_obj_set_model(MODEL_SUPER_BALL);
+        }
+        }
+    }
+	
+	if (m->action == ACT_JUMP)
+	{
+
+		m->marioObj->header.gfx.animInfo.animAccel = 0x20000;
+		if (!(m->flags & MARIO_IS_SUPER))
+		{
+			cur_obj_set_model(MODEL_SONIC_BALL);
+		}
+		else
+		{
+			cur_obj_set_model(MODEL_SUPER_BALL);
+		}
+
+		}
+
+	if (m->action == ACT_SHOT_FROM_CANNON)
+	{
+		
+		if (!(m->flags & MARIO_IS_SUPER))
+		{
+			cur_obj_set_model(MODEL_SONIC_BALL);
+		}
+		else
+		{
+			cur_obj_set_model(MODEL_SUPER_BALL);
+		}
+		
+
+	}
+
+	if (m->action == ACT_DIVE_SLIDE)
+	{
+		
+		if (!(m->flags & MARIO_IS_SUPER))
+			{
+				cur_obj_set_model(MODEL_SONIC_BALL);
+			}
+			else
+			{
+				cur_obj_set_model(MODEL_SUPER_BALL);
+			}
+
+
+	}
+
+	if (m->action == ACT_GROUND_POUND)
+	{
+
+		vec3f_set(m->marioObj->header.gfx.scale, 0.8f, 1.15f, 0.8f);
+		m->marioObj->header.gfx.animInfo.animAccel = 0x20000;
+		if (!(m->flags & MARIO_IS_SUPER))
+		{
+			cur_obj_set_model(MODEL_SONIC_BALL);
+		}
+		else
+		{
+			cur_obj_set_model(MODEL_SUPER_BALL);
+		}
+		
+
+	}
+
+	if (m->action == ACT_SPINDASH)
+	{
+		m->marioObj->header.gfx.angle[1] = m->faceAngle[1];
+		if (m->forwardVel < 50.0f)
+		{
+			m->marioObj->header.gfx.angle[0] = m->marioObj->header.gfx.angle[0] + 2900;
+		}
+		m->faceAngle[1] = m->intendedYaw;
+		vec3f_set(m->marioObj->header.gfx.scale, 0.85f, 1.0f, 0.85f);
+	
+
+
+	}
+
+
+
+
+
+	
+	if (m->action == ACT_JUMP)
+	{
+		if (m->actionTimer > 0 && m->actionTimer < 3)
+		{
+			cur_obj_scale(0.8f);
+			if (!(m->flags & MARIO_IS_SUPER))
+			{
+				cur_obj_set_model(MODEL_MARIO);
+			}
+			else
+			{
+				cur_obj_set_model(MODEL_SUPER_SONIC);
+			}
+			
+
+		}
+		else
+		{
+		
+			if (!(m->flags & MARIO_IS_SUPER))
+			{
+				cur_obj_set_model(MODEL_SONIC_BALL);
+			}
+			else
+			{
+				cur_obj_set_model(MODEL_SUPER_BALL);
+			}
+
+			//m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] - 35;
+			m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] + 50;
+			
+
+		}
+	}
+
 
     if (m->health >= 0x100) {
         // When already healing or hurting Mario, Mario's HP is not changed any more here.
         if (((u32) m->healCounter | (u32) m->hurtCounter) == 0) {
-            if ((m->input & INPUT_IN_POISON_GAS) && !(m->action & ACT_FLAG_INTANGIBLE)) {
-                if (!(m->flags & MARIO_METAL_CAP) && !gDebugLevelSelect) {
-                    m->health -= 4;
+            if ((m->input & INPUT_IN_POISON_GAS) && ((m->action & ACT_FLAG_INTANGIBLE) == 0)) {
+                if (((m->flags & MARIO_METAL_CAP) == 0) && (gDebugLevelSelect == 0)) {
+					if (gDialogHealthSystem != SONIC_HEALTH)
+					{
+						if (!(m->flags & MARIO_IS_SUPER))
+					{
+						m->health -= 4;
+					}
+					}
+					else
+					{
+						if (!(m->flags & MARIO_IS_SUPER))
+					{
+						m->gasTimer--;
+					
+						if (gMarioState->numCoins > 0)
+						{
+							if (m->gasTimer <= 0)
+							{
+								obj_spawn_yellow_coins(m->marioObj, 1);
+								gMarioState->numCoins -= 1;
+								gHudDisplay.coins -= 1;
+								m->gasTimer = 10;
+							}
+						}
+						else
+						{
+							m->health = 0xFF;
+						}
+						}
+					}
                 }
             } else {
-                if ((m->action & ACT_FLAG_SWIMMING) && !(m->action & ACT_FLAG_INTANGIBLE)) {
+                if ((m->action & ACT_FLAG_SWIMMING) && ((m->action & ACT_FLAG_INTANGIBLE) == 0)) {
                     terrainIsSnow = (m->area->terrainType & TERRAIN_MASK) == TERRAIN_SNOW;
 
                     // When Mario is near the water surface, recover health (unless in snow),
                     // when in snow terrains lose 3 health.
                     // If using the debug level select, do not lose any HP to water.
                     if ((m->pos[1] >= (m->waterLevel - 140)) && !terrainIsSnow) {
-                        m->health += 0x1A;
-                    } else if (!gDebugLevelSelect) {
-                        m->health -= (terrainIsSnow ? 3 : 1);
+                        m->health += 0x4F;
+                    } else if (gDebugLevelSelect == 0) {
+                       // m->health -= (terrainIsSnow ? 3 : 1);
                     }
                 }
             }
+			if (m->pos[1] <= (m->waterLevel - 140))
+			{
+				if (m->flags & MARIO_METAL_CAP || m->flags & MARIO_IS_SUPER)
+				{
+				}
+				else
+				{
+					if (gDialogHealthSystem != SONIC_HEALTH)
+					{
+						m->health -= (terrainIsSnow ? 3 : 1);
+					}
+					else
+					{
+						
+
+						 if (m->action != ACT_STAR_DANCE_WATER) {
+
+                                                m->drownTimer++;
+                                            }
+					}
+					//gMarioState->numLives = m->drownTimer;
+					if (m->drownTimer == 480)
+					{
+						play_sound(SOUND_MOVING_ALMOST_DROWNING, gGlobalSoundSource);
+					}
+
+					if (m->drownTimer == 540)
+					{
+						play_sound(SOUND_MOVING_ALMOST_DROWNING, gGlobalSoundSource);
+					}
+
+					if (m->drownTimer == 600)
+					{
+						play_drown_music();
+						spawn_orange_number(5, 0, 0 + 110, 0);
+					}
+					if (m->drownTimer == 660)
+					{
+						spawn_orange_number(4, 0, 0 + 110, 0);
+					}
+					if (m->drownTimer == 720)
+					{
+						spawn_orange_number(3, 0, 0 + 110, 0);
+					}
+					if (m->drownTimer == 780)
+					{
+						spawn_orange_number(2, 0, 0 + 110, 0);
+					}
+					if (m->drownTimer == 840)
+					{
+						spawn_orange_number(1, 0, 0 + 110, 0);
+					}
+
+					if 
+						(m->drownTimer == 900)
+					{
+						spawn_orange_number(0, 0 , 0 + 110, 0);
+					}
+
+					if (m->drownTimer == 950)
+					{
+						stop_drown_music();
+						set_mario_action(m, ACT_DROWNING, 0);
+					
+					}
+					if (m->drownTimer > 950)
+					{
+						stop_drown_music();
+
+					}
+
+				}
+			}
+			if (m->pos[1] >= (m->waterLevel - 120))
+			{
+				if (gCurrLevelNum != LEVEL_SL)
+				{
+					m->drownTimer = 0;
+					
+				}
+				else
+				{
+					m->drownTimer = 590;
+				}
+				if (!(m->action & ACT_FLAG_RIDING_SHELL))
+				{
+					stop_drown_music();
+				}
+			}
+			if ((m->pos[1] >= (m->waterLevel - 120)) && !terrainIsSnow && ((m->action == ACT_METAL_WATER_WALKING) || (m->action == ACT_WATER_JUMP))) {
+				m->health += 0x1A;
+			}
         }
 
         if (m->healCounter > 0) {
@@ -1485,7 +2366,7 @@ void update_mario_health(struct MarioState *m) {
             m->hurtCounter--;
         }
 
-        if (m->health > 0x880) {
+        if (m->health >= 0x881) {
             m->health = 0x880;
         }
         if (m->health < 0x100) {
@@ -1518,7 +2399,7 @@ void update_mario_info_for_cam(struct MarioState *m) {
 
     vec3s_copy(m->statusForCamera->faceAngle, m->faceAngle);
 
-    if (!(m->flags & MARIO_UNKNOWN_25)) {
+    if ((m->flags & MARIO_UNKNOWN_25) == 0) {
         vec3f_copy(m->statusForCamera->pos, m->pos);
     }
 }
@@ -1577,23 +2458,30 @@ u32 update_and_return_cap_flags(struct MarioState *m) {
         }
 
         if (m->capTimer == 0) {
-            stop_cap_music();
-
-            m->flags &= ~MARIO_SPECIAL_CAPS;
-            if (!(m->flags & MARIO_CAPS)) {
+			if (!(m->flags & MARIO_IS_SUPER))
+			{
+				stop_cap_music();
+			}
+
+            m->flags &= ~(MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP);
+            if ((m->flags & (MARIO_NORMAL_CAP | MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP))
+                == 0) {
                 m->flags &= ~MARIO_CAP_ON_HEAD;
             }
         }
-
-        if (m->capTimer == 60) {
-            fadeout_cap_music();
-        }
+		if (!(m->flags & MARIO_IS_SUPER))
+		{
+			if (m->capTimer == 0x3C) {
+				fadeout_cap_music();
+			}
+		}
 
         // This code flickers the cap through a long binary string, increasing in how
         // common it flickers near the end.
-        if ((m->capTimer < 64) && ((1ULL << m->capTimer) & sCapFlickerFrames)) {
-            flags &= ~MARIO_SPECIAL_CAPS;
-            if (!(flags & MARIO_CAPS)) {
+        if ((m->capTimer < 0x40) && ((1ULL << m->capTimer) & sCapFlickerFrames)) {
+            flags &= ~(MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP);
+            if ((flags & (MARIO_NORMAL_CAP | MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP))
+                == 0) {
                 flags &= ~MARIO_CAP_ON_HEAD;
             }
         }
@@ -1607,7 +2495,76 @@ u32 update_and_return_cap_flags(struct MarioState *m) {
  */
 void mario_update_hitbox_and_cap_model(struct MarioState *m) {
     struct MarioBodyState *bodyState = m->marioBodyState;
+    extern const u16 super_sonic_sonic_super_surface_rgba16[];
+    extern const u16 super_sonic_sonic_super_surface_replacer_rgba16[];
+    u16* supertexture = segmented_to_virtual(super_sonic_sonic_super_surface_rgba16);
+    u16* supertexturereplacer = segmented_to_virtual(super_sonic_sonic_super_surface_replacer_rgba16);
     s32 flags = update_and_return_cap_flags(m);
+  
+    m->marioObj->oSuperTimer += 1;
+
+
+    if (flags & MARIO_IS_SUPER) {
+        if (m->floor->type == SURFACE_BURNING) {
+            if (5.0f > absf(gMarioState->marioObj->oPosY - m->floorHeight)) {
+                spawn_object(gMarioState->marioObj, MODEL_RED_FLAME, bhvKoopaShellFlame);
+            }
+        }
+    }
+
+    switch (m->marioObj->oSuperTimer) {
+    
+    case 2:
+        bcopy(supertexturereplacer + 5, supertexture, 2 * 32 * 32);
+        
+        break;
+    case 4:
+        bcopy(supertexturereplacer + 10, supertexture, 2 * 32 * 32);
+        break;
+    case 6:
+        bcopy(supertexturereplacer + 15, supertexture, 2 * 32 * 32);
+        break;
+    case 8:
+        bcopy(supertexturereplacer + 20, supertexture, 2 * 32 * 32);
+        break;
+    case 10:
+        bcopy(supertexturereplacer + 25, supertexture, 2 * 32 * 32);
+        break;
+    case 12:
+        bcopy(supertexturereplacer + 30, supertexture, 2 * 32 * 32);
+        break;
+    case 14:
+        bcopy(supertexturereplacer + 35, supertexture, 2 * 32 * 32);
+        break;
+    case 16:
+        bcopy(supertexturereplacer + 40, supertexture, 2 * 32 * 32);
+        break;
+    case 18:
+        bcopy(supertexturereplacer + 45, supertexture, 2 * 32 * 32);
+        break;
+    case 20:
+        bcopy(supertexturereplacer + 50, supertexture, 2 * 32 * 32);
+        break;
+    case 22:
+        bcopy(supertexturereplacer + 55, supertexture, 2 * 32 * 32);
+        break;
+    case 24:
+        bcopy(supertexturereplacer + 60, supertexture, 2 * 32 * 32);
+        break;
+    case 26:
+        bcopy(supertexturereplacer + 0, supertexture, 2 * 32 * 32);
+        m->marioObj->oSuperTimer = 0;
+        break;
+    }
+
+
+
+
+
+
+
+
+
 
     if (flags & MARIO_VANISH_CAP) {
         bodyState->modelState = MODEL_STATE_NOISE_ALPHA;
@@ -1621,11 +2578,13 @@ void mario_update_hitbox_and_cap_model(struct MarioState *m) {
         bodyState->modelState |= MODEL_STATE_METAL;
     }
 
-    //! (Pause buffered hitstun) Since the global timer increments while paused,
-    //  this can be paused through to give continual invisibility. This leads to
-    //  no interaction with objects.
-    if ((m->invincTimer >= 3) && (gGlobalTimer & 1)) {
-        gMarioState->marioObj->header.gfx.node.flags |= GRAPH_RENDER_INVISIBLE;
+    if (m->invincTimer >= 3) {
+        //! (Pause buffered hitstun) Since the global timer increments while paused,
+        //  this can be paused through to give continual invisibility. This leads to
+        //  no interaction with objects.
+        if (gGlobalTimer & 1) {
+            gMarioState->marioObj->header.gfx.node.flags |= GRAPH_RENDER_INVISIBLE;
+        }
     }
 
     if (flags & MARIO_CAP_IN_HAND) {
@@ -1666,7 +2625,7 @@ static void debug_update_mario_cap(u16 button, s32 flags, u16 capTimer, u16 capM
     // (which is also what other debug functions do),
     // so likely debug behavior rather than unused behavior.
     if ((gPlayer1Controller->buttonDown & Z_TRIG) && (gPlayer1Controller->buttonPressed & button)
-        && !(gMarioState->flags & flags)) {
+        && ((gMarioState->flags & flags) == 0)) {
         gMarioState->flags |= (flags + MARIO_CAP_ON_HEAD);
 
         if (capTimer > gMarioState->capTimer) {
@@ -1785,11 +2744,12 @@ s32 execute_mario_action(UNUSED struct Object *o) {
  **************************************************/
 
 void init_mario(void) {
+
     Vec3s capPos;
     struct Object *capObject;
 
     unused80339F10 = 0;
-
+    gMarioState->hasEmerald = save_file_get_star_flags(gCurrSaveFileNum - 1, gCurrCourseNum - 1) & (1 << 6);
     gMarioState->actionTimer = 0;
     gMarioState->framesSinceA = 0xFF;
     gMarioState->framesSinceB = 0xFF;
@@ -1798,12 +2758,15 @@ void init_mario(void) {
 
     if (save_file_get_flags()
         & (SAVE_FLAG_CAP_ON_GROUND | SAVE_FLAG_CAP_ON_KLEPTO | SAVE_FLAG_CAP_ON_UKIKI
-           | SAVE_FLAG_CAP_ON_MR_BLIZZARD)) {
+           | SAVE_FLAG_CAP_ON_MR_BLIZZARD )) {
         gMarioState->flags = 0;
     } else {
-        gMarioState->flags = (MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
-    }
 
+			gMarioState->flags = (MARIO_CAP_ON_HEAD | MARIO_NORMAL_CAP);
+
+    }
+   //gMarioState->flags |= MARIO_IS_SHADOW;
+   gMarioState->flags &= ~MARIO_IS_SHADOW;
     gMarioState->forwardVel = 0.0f;
     gMarioState->squishTimer = 0;
 
