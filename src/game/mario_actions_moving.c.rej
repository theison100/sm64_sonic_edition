diff a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c	(rejected hunks)
@@ -1,5 +1,5 @@
 #include <PR/ultratypes.h>
-
+#include "types.h"
 #include "sm64.h"
 #include "mario.h"
 #include "audio/external.h"
@@ -12,6 +12,8 @@
 #include "memory.h"
 #include "behavior_data.h"
 #include "rumble_init.h"
+#include "ingame_menu.h"
+#include "level_update.h"
 
 struct LandingAction {
     s16 numFrames;
@@ -24,15 +26,15 @@ struct LandingAction {
 };
 
 struct LandingAction sJumpLandAction = {
-    4, 5, ACT_FREEFALL, ACT_JUMP_LAND_STOP, ACT_DOUBLE_JUMP, ACT_FREEFALL, ACT_BEGIN_SLIDING,
+    4, 5, ACT_FREEFALL, ACT_JUMP_LAND_STOP, ACT_JUMP, ACT_FREEFALL, ACT_BEGIN_SLIDING,
 };
 
 struct LandingAction sFreefallLandAction = {
-    4, 5, ACT_FREEFALL, ACT_FREEFALL_LAND_STOP, ACT_DOUBLE_JUMP, ACT_FREEFALL, ACT_BEGIN_SLIDING,
+    4, 5, ACT_FREEFALL, ACT_FREEFALL_LAND_STOP, ACT_JUMP, ACT_FREEFALL, ACT_BEGIN_SLIDING,
 };
 
 struct LandingAction sSideFlipLandAction = {
-    4, 5, ACT_FREEFALL, ACT_SIDE_FLIP_LAND_STOP, ACT_DOUBLE_JUMP, ACT_FREEFALL, ACT_BEGIN_SLIDING,
+    4, 5, ACT_FREEFALL, ACT_SIDE_FLIP_LAND_STOP, ACT_JUMP, ACT_FREEFALL, ACT_BEGIN_SLIDING,
 };
 
 struct LandingAction sHoldJumpLandAction = {
@@ -62,9 +64,12 @@ struct LandingAction sBackflipLandAction = {
 Mat4 sFloorAlignMatrix[2];
 
 s16 tilt_body_running(struct MarioState *m) {
-    s16 pitch = find_floor_slope(m, 0);
-    pitch = pitch * m->forwardVel / 40.0f;
-    return -pitch;
+	if (m->floorHeight != m->waterLevel)
+	{
+		s16 pitch = find_floor_slope(m, 0);
+		pitch = pitch * m->forwardVel / 40.0f;
+		return -pitch;
+	}
 }
 
 void play_step_sound(struct MarioState *m, s16 frame1, s16 frame2) {
@@ -86,9 +91,37 @@ void play_step_sound(struct MarioState *m, s16 frame1, s16 frame2) {
 }
 
 void align_with_floor(struct MarioState *m) {
-    m->pos[1] = m->floorHeight;
-    mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], m->pos, m->faceAngle[1], 40.0f);
-    m->marioObj->header.gfx.throwMatrix = &sFloorAlignMatrix[m->unk00];
+    if (m->action != ACT_DIVE_SLIDE)
+    {
+	m->pos[1] = m->floorHeight;
+    }
+    else
+    {
+        m->pos[1] = m->floorHeight + 30;
+    }
+        mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], m->pos, m->faceAngle[1], 40.0f);
+        m->marioObj->header.gfx.throwMatrix = &sFloorAlignMatrix[m->unk00];
+    
+
+
+
+
+	if (m->action == ACT_SPINDASH)
+	{
+		//m->marioObj->header.gfx.angle[0] = m->marioObj->header.gfx.angle[0] + 280;
+		m->marioObj->header.gfx.angle[1] = m->faceAngle[1];
+		vec3f_set(m->marioObj->header.gfx.scale, 0.8f, 1.05f, 0.8f);
+
+	}
+	else
+	{
+		if (m->action != ACT_DIVE_SLIDE)
+		{
+			mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], m->pos, m->faceAngle[1], 40.0f);
+			m->marioObj->header.gfx.throwMatrix = &sFloorAlignMatrix[m->unk00];
+		}
+	}
+	
 }
 
 s32 begin_walking_action(struct MarioState *m, f32 forwardVel, u32 action, u32 actionArg) {
@@ -114,20 +147,22 @@ void check_ledge_climb_down(struct MarioState *m) {
 
         if (find_wall_collisions(&wallCols) != 0) {
             floorHeight = find_floor(wallCols.x, wallCols.y, wallCols.z, &floor);
-            if (floor != NULL && (wallCols.y - floorHeight > 160.0f)) {
-                wall = wallCols.walls[wallCols.numWalls - 1];
-                wallAngle = atan2s(wall->normal.z, wall->normal.x);
-                wallDYaw = wallAngle - m->faceAngle[1];
+            if (floor != NULL) {
+                if (wallCols.y - floorHeight > 160.0f) {
+                    wall = wallCols.walls[wallCols.numWalls - 1];
+                    wallAngle = atan2s(wall->normal.z, wall->normal.x);
+                    wallDYaw = wallAngle - m->faceAngle[1];
 
-                if (wallDYaw > -0x4000 && wallDYaw < 0x4000) {
-                    m->pos[0] = wallCols.x - 20.0f * wall->normal.x;
-                    m->pos[2] = wallCols.z - 20.0f * wall->normal.z;
+                    if (wallDYaw > -0x4000 && wallDYaw < 0x4000) {
+                        m->pos[0] = wallCols.x - 20.0f * wall->normal.x;
+                        m->pos[2] = wallCols.z - 20.0f * wall->normal.z;
 
-                    m->faceAngle[0] = 0;
-                    m->faceAngle[1] = wallAngle + 0x8000;
+                        m->faceAngle[0] = 0;
+                        m->faceAngle[1] = wallAngle + 0x8000;
 
-                    set_mario_action(m, ACT_LEDGE_CLIMB_DOWN, 0);
-                    set_mario_animation(m, MARIO_ANIM_CLIMB_DOWN_LEDGE);
+                        set_mario_action(m, ACT_LEDGE_CLIMB_DOWN, 0);
+                        set_mario_animation(m, MARIO_ANIM_CLIMB_DOWN_LEDGE);
+                    }
                 }
             }
         }
@@ -135,7 +170,7 @@ void check_ledge_climb_down(struct MarioState *m) {
 }
 
 void slide_bonk(struct MarioState *m, u32 fastAction, u32 slowAction) {
-    if (m->forwardVel > 16.0f) {
+    if (m->forwardVel > 70.0f) {
         mario_bonk_reflection(m, TRUE);
         drop_and_set_mario_action(m, fastAction, 0);
     } else {
@@ -144,76 +179,195 @@ void slide_bonk(struct MarioState *m, u32 fastAction, u32 slowAction) {
     }
 }
 
-s32 set_triple_jump_action(struct MarioState *m, UNUSED u32 action, UNUSED u32 actionArg) {
-    if (m->flags & MARIO_WING_CAP) {
-        return set_mario_action(m, ACT_FLYING_TRIPLE_JUMP, 0);
-    } else if (m->forwardVel > 20.0f) {
-        return set_mario_action(m, ACT_TRIPLE_JUMP, 0);
-    } else {
-        return set_mario_action(m, ACT_JUMP, 0);
-    }
-
-    return FALSE;
-}
 
-void update_sliding_angle(struct MarioState *m, f32 accel, f32 lossFactor) {
-    s32 newFacingDYaw;
-    s16 facingDYaw;
 
-    struct Surface *floor = m->floor;
-    s16 slopeAngle = atan2s(floor->normal.z, floor->normal.x);
-    f32 steepness = sqrtf(floor->normal.x * floor->normal.x + floor->normal.z * floor->normal.z);
-    UNUSED f32 normalY = floor->normal.y;
 
-    m->slideVelX += accel * steepness * sins(slopeAngle);
-    m->slideVelZ += accel * steepness * coss(slopeAngle);
+s32 act_spindash(struct MarioState *m) {
+	m->faceAngle[1] = m->intendedYaw;
+	if (!(m->flags & MARIO_IS_SUPER))
+	{
+		cur_obj_set_model(MODEL_SONIC_BALL);
+	}
+	else
+	{
+		cur_obj_set_model(MODEL_SUPER_BALL);
+	}
+	m->marioObj->header.gfx.animInfo.animAccel = 0x10000 + 0x0200 * m->forwardVel;
+	
+	//play_mario_action_sound(m, SOUND_MARIO_PUNCH_HOO, 1);
+	set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING);
+	
 
-    m->slideVelX *= lossFactor;
-    m->slideVelZ *= lossFactor;
 
-    m->slideYaw = atan2s(m->slideVelZ, m->slideVelX);
+	if (!(m->input & INPUT_Z_DOWN)) {
+		m->actionTimer = 0;
+		set_mario_action(m, ACT_DIVE_SLIDE, 0);
+		mario_set_forward_vel(m, m->forwardVel);
+	}
 
-    facingDYaw = m->faceAngle[1] - m->slideYaw;
-    newFacingDYaw = facingDYaw;
+	vec3f_set(m->marioObj->header.gfx.scale, 0.6f, 1.0f, 0.6f);
 
-    //! -0x4000 not handled - can slide down a slope while facing perpendicular to it
-    if (newFacingDYaw > 0 && newFacingDYaw <= 0x4000) {
-        if ((newFacingDYaw -= 0x200) < 0) {
-            newFacingDYaw = 0;
-        }
-    } else if (newFacingDYaw > -0x4000 && newFacingDYaw < 0) {
-        if ((newFacingDYaw += 0x200) > 0) {
-            newFacingDYaw = 0;
-        }
-    } else if (newFacingDYaw > 0x4000 && newFacingDYaw < 0x8000) {
-        if ((newFacingDYaw += 0x200) > 0x8000) {
-            newFacingDYaw = 0x8000;
-        }
-    } else if (newFacingDYaw > -0x8000 && newFacingDYaw < -0x4000) {
-        if ((newFacingDYaw -= 0x200) < -0x8000) {
-            newFacingDYaw = -0x8000;
-        }
-    }
+	if (m->forwardVel < 50.0f)
+	{
+		m->marioObj->header.gfx.angle[0] = m->marioObj->header.gfx.angle[0] + 200;
+		m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] + 30;
+		
+		m->forwardVel = 50.0f;
+	}
 
-    m->faceAngle[1] = m->slideYaw + newFacingDYaw;
+	if (m->input & INPUT_B_PRESSED ) {
+		if (m->forwardVel <= 200)
+		{
+			m->particleFlags |= PARTICLE_DUST;
+			
+			m->forwardVel += 40.0f;
 
-    m->vel[0] = m->slideVelX;
-    m->vel[1] = 0.0f;
-    m->vel[2] = m->slideVelZ;
+		}
+		else
+		{
+			m->forwardVel = 200;
+		}
+		play_sound(SOUND_MARIO_YAWNING,
+			m->marioObj->header.gfx.cameraToObject);
+		set_mario_action(m, ACT_SPINDASH, m->forwardVel/10);
+		
+		
+		//play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, 1);
+	}
 
-    mario_update_moving_sand(m);
-    mario_update_windy_ground(m);
+	return FALSE;
+}
 
-    //! Speed is capped a frame late (butt slide HSG)
-    m->forwardVel = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
-    if (m->forwardVel > 100.0f) {
-        m->slideVelX = m->slideVelX * 100.0f / m->forwardVel;
-        m->slideVelZ = m->slideVelZ * 100.0f / m->forwardVel;
+s32 set_triple_jump_action(struct MarioState *m, UNUSED u32 action, UNUSED u32 actionArg) {
+    if (m->flags & MARIO_WING_CAP) {
+        return set_mario_action(m, ACT_FLYING_TRIPLE_JUMP, 0);
+    } else if (m->forwardVel > 20.0f) {
+        return set_mario_action(m, ACT_TRIPLE_JUMP, 0);
+    } else {
+        return set_mario_action(m, ACT_JUMP, 0);
     }
 
-    if (newFacingDYaw < -0x4000 || newFacingDYaw > 0x4000) {
-        m->forwardVel *= -1.0f;
-    }
+    return 0;
+}
+
+void update_sliding_angle(struct MarioState *m, f32 accel, f32 lossFactor) {
+	s32 newFacingDYaw;
+	s16 facingDYaw;
+	s32 setdash = FALSE;
+
+	struct Surface *floor = m->floor;
+	s16 slopeAngle = atan2s(floor->normal.z, floor->normal.x);
+	f32 steepness = sqrtf(floor->normal.x * floor->normal.x + floor->normal.z * floor->normal.z);
+	UNUSED f32 normalY = floor->normal.y;
+
+	m->slideVelX += accel * steepness * sins(slopeAngle);
+	m->slideVelZ += accel * steepness * coss(slopeAngle);
+
+	m->slideVelX *= lossFactor;
+	m->slideVelZ *= lossFactor;
+
+	m->slideYaw = atan2s(m->slideVelZ, m->slideVelX);
+
+	facingDYaw = m->faceAngle[1] - m->slideYaw;
+	newFacingDYaw = facingDYaw;
+
+
+	//! -0x4000 not handled - can slide down a slope while facing perpendicular to it
+	if (newFacingDYaw > 0 && newFacingDYaw <= 0x4000) {
+		if ((newFacingDYaw -= 0x200) < 0) {
+			newFacingDYaw = 0;
+		}
+	}
+	else if (newFacingDYaw > -0x4000 && newFacingDYaw < 0) {
+		if ((newFacingDYaw += 0x200) > 0) {
+			newFacingDYaw = 0;
+		}
+	}
+	else if (newFacingDYaw > 0x4000 && newFacingDYaw < 0x8000) {
+		if ((newFacingDYaw += 0x200) > 0x8000) {
+			newFacingDYaw = 0x8000;
+		}
+	}
+	else if (newFacingDYaw > -0x8000 && newFacingDYaw < -0x4000) {
+		if ((newFacingDYaw -= 0x200) < -0x8000) {
+			newFacingDYaw = -0x8000;
+		}
+	}
+
+	
+
+	if (m->action == ACT_DIVE_SLIDE || m->action == ACT_HOLD_STOMACH_SLIDE)
+	{
+		m->faceAngle[1] = m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
+	}
+	else
+	{
+		m->faceAngle[1] = m->slideYaw + newFacingDYaw;
+
+	}
+    if (m->action == ACT_SLIDE_KICK_SLIDE && m->actionTimer == 1)
+    {
+	m->vel[0] = m->slideVelX *= 1.6;
+	m->vel[1] = 0.0f;
+	m->vel[2] = m->slideVelZ *= 1.6;
+    }
+    else
+    {
+        m->vel[0] = m->slideVelX;
+        m->vel[1] = 0.0f;
+        m->vel[2] = m->slideVelZ;
+    }
+
+	mario_update_moving_sand(m);
+	mario_update_windy_ground(m);
+
+	//! Speed is capped a frame late (butt slide HSG)
+	m->forwardVel = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
+	if (m->forwardVel > 150.0f && m->action == ACT_DIVE_SLIDE && m->prevAction == ACT_SPINDASH)
+	{
+		if (!(m->flags & MARIO_IS_SUPER))
+		{
+			m->actionTimer++;
+		}
+
+		if (m->forwardVel > 150.0f) {
+			if (!(m->flags & MARIO_IS_SUPER))
+			{
+				m->particleFlags |= PARTICLE_SONIC_TRAIL_ROLLING;
+			}
+			else
+			{
+				m->particleFlags |= PARTICLE_SUPER_TRAIL_ROLLING;
+			}
+
+		}
+		if (m->forwardVel > 200.0f) {
+			if (!(m->flags & MARIO_IS_SUPER))
+			{
+				m->forwardVel--;
+			}
+			else
+			{
+				m->forwardVel += 10.0f;
+			}
+			m->slideVelX = m->slideVelX * 200.0f / m->forwardVel;
+			m->slideVelZ = m->slideVelZ * 200.0f / m->forwardVel;
+			
+		}
+	}
+	else
+	{
+		if (m->forwardVel > 150.0f) {
+			m->slideVelX = m->slideVelX * 150.0f / m->forwardVel;
+			m->slideVelZ = m->slideVelZ * 150.0f / m->forwardVel;
+		}
+
+		
+	}
+
+	if (newFacingDYaw < -0x4000 || newFacingDYaw > 0x4000) {
+		m->forwardVel *= -1.0f;
+	}
 }
 
 s32 update_sliding(struct MarioState *m, f32 stopSpeed) {
@@ -228,6 +382,7 @@ s32 update_sliding(struct MarioState *m, f32 stopSpeed) {
     f32 forward = coss(intendedDYaw);
     f32 sideward = sins(intendedDYaw);
 
+
     //! 10k glitch
     if (forward < 0.0f && m->forwardVel >= 0.0f) {
         forward *= 0.5f + 0.5f * m->forwardVel / 100.0f;
@@ -235,23 +390,65 @@ s32 update_sliding(struct MarioState *m, f32 stopSpeed) {
 
     switch (mario_get_floor_class(m)) {
         case SURFACE_CLASS_VERY_SLIPPERY:
-            accel = 10.0f;
-            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.98f;
+			if ((m->action == ACT_DIVE_SLIDE || m->action == ACT_HOLD_STOMACH_SLIDE) && mario_facing_downhill(m, TRUE))
+			{
+
+				accel = 26.0f;
+			
+				lossFactor = m->intendedMag / 11.0f * forward * 0.02f + 0.98f;
+			}
+			else
+			{
+
+				accel = 10.0f;
+				lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.98f;
+			}
+            
             break;
 
         case SURFACE_CLASS_SLIPPERY:
-            accel = 8.0f;
-            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.96f;
+			if ((m->action == ACT_DIVE_SLIDE || m->action == ACT_HOLD_STOMACH_SLIDE) && mario_facing_downhill(m, TRUE))
+			{
+
+				accel = 23.0f;
+				lossFactor = m->intendedMag / 11.0f * forward * 0.02f + 0.96f;
+			}
+			else
+			{
+				accel = 8.0f;
+				lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.96f;
+			}
+    
             break;
 
         default:
-            accel = 7.0f;
-            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
+			if ((m->action == ACT_DIVE_SLIDE || m->action == ACT_HOLD_STOMACH_SLIDE) && mario_facing_downhill(m, TRUE))
+			{
+
+				accel = 20.0f;
+				lossFactor = m->intendedMag / 11.0f * forward * 0.01f + 0.92f;
+			}
+			else
+			{
+				accel = 7.0f;
+				lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
+			}
+
             break;
 
         case SURFACE_CLASS_NOT_SLIPPERY:
-            accel = 5.0f;
-            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
+			if ((m->action == ACT_DIVE_SLIDE || m->action == ACT_HOLD_STOMACH_SLIDE) && mario_facing_downhill(m, TRUE))
+			{
+
+				accel = 5.0f;
+				lossFactor = m->intendedMag / 11.0f * forward * 0.01f + 0.92f;
+			}
+			else
+			{
+				accel = 0.1f;
+				lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
+			}
+
             break;
     }
 
@@ -272,6 +469,7 @@ s32 update_sliding(struct MarioState *m, f32 stopSpeed) {
 
     update_sliding_angle(m, accel, lossFactor);
 
+
     if (!mario_floor_is_slope(m) && m->forwardVel * m->forwardVel < stopSpeed * stopSpeed) {
         mario_set_forward_vel(m, 0.0f);
         stopped = TRUE;
@@ -297,18 +495,94 @@ void apply_slope_accel(struct MarioState *m) {
         }
 
         switch (slopeClass) {
-            case SURFACE_CLASS_VERY_SLIPPERY:
-                slopeAccel = 5.3f;
-                break;
-            case SURFACE_CLASS_SLIPPERY:
-                slopeAccel = 2.7f;
-                break;
-            default:
-                slopeAccel = 1.7f;
-                break;
-            case SURFACE_CLASS_NOT_SLIPPERY:
-                slopeAccel = 0.0f;
-                break;
+			
+			{
+		case SURFACE_CLASS_VERY_SLIPPERY:
+			if (m->action == ACT_DIVE_SLIDE)
+			{
+				if (m->forwardVel < 50.0f)
+				{
+					slopeAccel = 5.3f;
+				}
+				else
+				{
+					slopeAccel = 0.0f;
+				}
+			}
+			else
+			{ 
+				if (m->forwardVel < 50.0f)
+				{
+					slopeAccel = 5.3f;
+				}
+				else
+				{
+					slopeAccel = 0.0f;
+				}
+			}
+				break;
+		case SURFACE_CLASS_SLIPPERY:
+			if (m->action == ACT_DIVE_SLIDE)
+			{
+				if (m->forwardVel < 50.0f)
+				{
+					slopeAccel = 2.7f;
+				}
+				else
+				{
+					slopeAccel = 0.0f;
+				}
+			}
+			else
+			{
+				if (m->forwardVel < 50.0f)
+				{
+					slopeAccel = 2.7f;
+				}
+				else
+				{
+					slopeAccel = 0.0f;
+				}
+			}
+
+			break;
+		default:
+			if (m->action == ACT_DIVE_SLIDE)
+			{
+				if (m->forwardVel < 50.0f)
+				{
+					slopeAccel = 1.0f;
+				}
+				else
+				{
+					slopeAccel = 0.0f;
+				}
+			}
+			else
+			{
+				if (m->forwardVel < 50.0f)
+				{
+					slopeAccel = 1.0f;
+				}
+				else
+				{
+					slopeAccel = 0.0f;
+				}
+			}
+			break;
+		case SURFACE_CLASS_NOT_SLIPPERY:
+			if (m->forwardVel < 50.0f)
+			{
+				slopeAccel = 0.4f;
+			}
+			else
+			{
+				slopeAccel = 0.0f;
+			}
+			break;
+			
+
+			}
         }
 
         if (floorDYaw > -0x4000 && floorDYaw < 0x4000) {
@@ -347,6 +621,7 @@ s32 apply_landing_accel(struct MarioState *m, f32 frictionFactor) {
     return stopped;
 }
 
+
 void update_shell_speed(struct MarioState *m) {
     f32 maxTargetSpeed;
     f32 targetSpeed;
@@ -355,6 +630,7 @@ void update_shell_speed(struct MarioState *m) {
         m->floorHeight = m->waterLevel;
         m->floor = &gWaterSurfacePseudoFloor;
         m->floor->originOffset = m->waterLevel; //! Negative origin offset
+
     }
 
     if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
@@ -384,8 +660,7 @@ void update_shell_speed(struct MarioState *m) {
         m->forwardVel = 64.0f;
     }
 
-    m->faceAngle[1] =
-        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
+    m->faceAngle[1] =    m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
 
     apply_slope_accel(m);
 }
@@ -395,18 +670,20 @@ s32 apply_slope_decel(struct MarioState *m, f32 decelCoef) {
     s32 stopped = FALSE;
 
     switch (mario_get_floor_class(m)) {
+
         case SURFACE_CLASS_VERY_SLIPPERY:
-            decel = decelCoef * 0.2f;
+            decel = decelCoef * 0.8f ;
             break;
         case SURFACE_CLASS_SLIPPERY:
-            decel = decelCoef * 0.7f;
+            decel = decelCoef * 0.9f ;
             break;
         default:
-            decel = decelCoef * 2.0f;
+            decel = decelCoef * 1.5f ;
             break;
         case SURFACE_CLASS_NOT_SLIPPERY:
-            decel = decelCoef * 3.0f;
+			decel = decelCoef * 1.0f ;
             break;
+
     }
 
     if ((m->forwardVel = approach_f32(m->forwardVel, 0.0f, decel, decel)) == 0.0f) {
@@ -435,10 +712,14 @@ void update_walking_speed(struct MarioState *m) {
     f32 maxTargetSpeed;
     f32 targetSpeed;
 
+
+
+
+
     if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
-        maxTargetSpeed = 24.0f;
+        maxTargetSpeed = 800.0f;
     } else {
-        maxTargetSpeed = 32.0f;
+        maxTargetSpeed = 1000.0f;
     }
 
     targetSpeed = m->intendedMag < maxTargetSpeed ? m->intendedMag : maxTargetSpeed;
@@ -450,25 +731,28 @@ void update_walking_speed(struct MarioState *m) {
     if (m->forwardVel <= 0.0f) {
         m->forwardVel += 1.1f;
     } else if (m->forwardVel <= targetSpeed) {
-        m->forwardVel += 1.1f - m->forwardVel / 43.0f;
+        m->forwardVel += 1.1f - m->forwardVel / 1050.0f;
     } else if (m->floor->normal.y >= 0.95f) {
         m->forwardVel -= 1.0f;
     }
 
-    if (m->forwardVel > 48.0f) {
-        m->forwardVel = 48.0f;
+    if (m->forwardVel > 200.0f) {
+        m->forwardVel = 200.0f;
     }
 
-    m->faceAngle[1] =
-        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
+    /* Handles the "Super responsive controls" cheat. The content of the "else" is Mario's original code for turning around.*/
+    m->faceAngle[1] = m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
+    
     apply_slope_accel(m);
 }
 
 s32 should_begin_sliding(struct MarioState *m) {
     if (m->input & INPUT_ABOVE_SLIDE) {
         s32 slideLevel = (m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE;
+		
         s32 movingBackward = m->forwardVel <= -1.0f;
 
+
         if (slideLevel || movingBackward || mario_facing_downhill(m, FALSE)) {
             return TRUE;
         }
@@ -486,11 +770,7 @@ s32 check_ground_dive_or_punch(struct MarioState *m) {
     UNUSED s32 unused;
 
     if (m->input & INPUT_B_PRESSED) {
-        //! Speed kick (shoutouts to SimpleFlips)
-        if (m->forwardVel >= 29.0f && m->controller->stickMag > 48.0f) {
-            m->vel[1] = 20.0f;
-            return set_mario_action(m, ACT_DIVE, 1);
-        }
+
 
         return set_mario_action(m, ACT_MOVE_PUNCHING, 0);
     }
@@ -570,7 +850,7 @@ void anim_and_audio_for_walk(struct MarioState *m) {
                 case 2:
                     if (val04 < 5.0f) {
                         m->actionTimer = 1;
-                    } else if (val04 > 22.0f) {
+                    } else if (val04 > 60.0f) {
                         m->actionTimer = 3;
                     } else {
                         //! (Speed Crash) If Mario's speed is more than 2^17.
@@ -583,13 +863,76 @@ void anim_and_audio_for_walk(struct MarioState *m) {
                     break;
 
                 case 3:
-                    if (val04 < 18.0f) {
+                    if (val04 < 55.0f) {
                         m->actionTimer = 2;
                     } else {
                         //! (Speed Crash) If Mario's speed is more than 2^17.
-                        val14 = (s32)(val04 / 4.0f * 0x10000);
-                        set_mario_anim_with_accel(m, MARIO_ANIM_RUNNING, val14);
-                        play_step_sound(m, 9, 45);
+                        
+						if (m->forwardVel < 45.0f)
+						{
+							val14 = (s32)(val04 / 7.5f * 0x10000);
+					
+								set_mario_anim_with_accel(m, MARIO_ANIM_RUNNING, val14);
+								
+						
+							
+						}
+						else
+						{
+							
+
+							if (m->flags & MARIO_IS_SUPER)
+							{
+								val14 = (s32)(val04 / 10.5f * 0x10000);
+                                //sonic super flying
+								set_mario_anim_with_accel(m, MARIO_ANIM_BEND_KNESS_RIDING_SHELL, val14);
+							}
+							else
+							{
+                                if (!(m->flags & MARIO_IS_SHADOW)) {
+                                    val14 = (s32)(val04 / 6.8f * 0x10000);
+                                    //sonic full speed run
+                                    set_mario_anim_with_accel(m, MARIO_ANIM_FORWARD_FLIP, val14);
+                                }
+                                else
+                                {
+                                    val14 = (s32)(val04 / 30.5f * 0x10000);
+                                    //shadow full speed run
+                                    set_mario_anim_with_accel(m, MARIO_ANIM_QUICKLY_PUT_CAP_ON, val14);
+                                }
+							}
+							if (m->forwardVel < 85.0f)
+							{
+								m->marioBodyState->handState = MARIO_HAND_OPEN;
+							}
+						}
+						if (!(m->flags & MARIO_IS_SUPER) || (m->forwardVel < 45.0f) )
+						{
+                           
+                            if (m->flags & MARIO_IS_SHADOW && m->forwardVel > 45.0f)
+                            {
+                                play_step_sound(m, 2, 27);
+                                if ((m->marioObj->header.gfx.animInfo.animFrame > 2 && 21 > m->marioObj->header.gfx.animInfo.animFrame) || (m->marioObj->header.gfx.animInfo.animFrame > 27 && 46 > m->marioObj->header.gfx.animInfo.animFrame)) {
+                                    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+                                    //|| m->marioObj->header.gfx.animInfo.animFrame == 30) 
+                                    m->particleFlags |= PARTICLE_DUST;
+                                }
+                          }
+                            else
+                            { 
+							play_step_sound(m, 9, 45);
+                            }
+                           
+						}
+						else
+						{
+							
+								play_sound(SOUND_MOVING_FLYING, m->marioObj->header.gfx.cameraToObject);
+								adjust_sound_for_speed(m);
+					
+						}
+						
+						//play_step_sound(m, 27, 63);
                         targetPitch = tilt_body_running(m);
 
                         val0C = FALSE;
@@ -713,7 +1056,7 @@ void tilt_body_walking(struct MarioState *m, s16 startYaw) {
     UNUSED struct Object *marioObj = m->marioObj;
     s16 animID = m->marioObj->header.gfx.animInfo.animID;
 
-    if (animID == MARIO_ANIM_WALKING || animID == MARIO_ANIM_RUNNING) {
+    if (animID == MARIO_ANIM_WALKING || animID == MARIO_ANIM_RUNNING || animID == MARIO_ANIM_FORWARD_FLIP || animID == MARIO_ANIM_BEND_KNESS_RIDING_SHELL || animID == MARIO_ANIM_QUICKLY_PUT_CAP_ON) {
         s16 dYaw = m->faceAngle[1] - startYaw;
         //! (Speed Crash) These casts can cause a crash if (dYaw * forwardVel / 12) or
         //! (forwardVel * 170) exceed or equal 2^31.
@@ -774,18 +1117,46 @@ void tilt_body_ground_shell(struct MarioState *m, s16 startYaw) {
     marioObj->header.gfx.pos[1] += 45.0f;
 }
 
+
+
+
+
+
 s32 act_walking(struct MarioState *m) {
     Vec3f startPos;
     s16 startYaw = m->faceAngle[1];
-
     mario_drop_held_object(m);
 
+	
+
+
+	//m->particleFlags |= PARTICLE_SHALLOW_WATER_WAVE;
+
+
+
+	if (m->floorHeight < m->waterLevel && m->forwardVel > 45.0f) {
+		m->floorHeight = m->waterLevel;
+		m->floor = &gWaterSurfacePseudoFloor;
+		m->floor->originOffset = m->waterLevel; //! Negative origin offset
+		
+
+		spawn_object(m->marioObj, MODEL_WAVE_TRAIL, bhvObjectWaveTrail);
+
+	}
+
+
+
     if (should_begin_sliding(m)) {
-        return set_mario_action(m, ACT_BEGIN_SLIDING, 0);
+		if (ACT_WALKING && m->forwardVel > 100.0f)
+		{
+			return set_mario_action(m, ACT_BEGIN_SLIDING, 0);
+		}
     }
 
     if (m->input & INPUT_FIRST_PERSON) {
-        return begin_braking_action(m);
+
+			return begin_braking_action(m);
+		
     }
 
     if (m->input & INPUT_A_PRESSED) {
@@ -805,7 +1176,15 @@ s32 act_walking(struct MarioState *m) {
     }
 
     if (m->input & INPUT_Z_PRESSED) {
-        return set_mario_action(m, ACT_CROUCH_SLIDE, 0);
+
+       if  (m->forwardVel >= 2.0f)
+        {
+        return set_mario_action(m, ACT_DIVE_SLIDE, 0);
+        }
+    else
+    {
+        return set_mario_action(m, ACT_START_CROUCHING, 0);
+    }
     }
 
     m->actionState = 0;
@@ -851,6 +1230,7 @@ s32 act_move_punching(struct MarioState *m) {
     mario_update_punch_sequence(m);
 
     if (m->forwardVel >= 0.0f) {
+
         apply_slope_decel(m, 0.5f);
     } else {
         if ((m->forwardVel += 8.0f) >= 0.0f) {
@@ -873,6 +1253,7 @@ s32 act_move_punching(struct MarioState *m) {
 }
 
 s32 act_hold_walking(struct MarioState *m) {
+
     if (m->heldObj->behavior == segmented_to_virtual(bhvJumpingBox)) {
         return set_mario_action(m, ACT_CRAZY_BOX_BOUNCE, 0);
     }
@@ -898,7 +1279,7 @@ s32 act_hold_walking(struct MarioState *m) {
     }
 
     if (m->input & INPUT_Z_PRESSED) {
-        return drop_and_set_mario_action(m, ACT_CROUCH_SLIDE, 0);
+        return drop_and_set_mario_action(m, ACT_CROUCHING, 0);
     }
 
     m->intendedMag *= 0.4f;
@@ -1091,7 +1472,7 @@ s32 act_decelerating(struct MarioState *m) {
         }
 
         if (m->input & INPUT_Z_PRESSED) {
-            return set_mario_action(m, ACT_CROUCH_SLIDE, 0);
+            return set_mario_action(m, ACT_START_CROUCHING, 0);
         }
     }
 
@@ -1152,7 +1533,7 @@ s32 act_hold_decelerating(struct MarioState *m) {
     }
 
     if (m->input & INPUT_Z_PRESSED) {
-        return drop_and_set_mario_action(m, ACT_CROUCH_SLIDE, 0);
+        return drop_and_set_mario_action(m, ACT_START_CROUCHING, 0);
     }
 
     if (m->input & INPUT_NONZERO_ANALOG) {
@@ -1198,7 +1579,7 @@ s32 act_hold_decelerating(struct MarioState *m) {
 }
 
 s32 act_riding_shell_ground(struct MarioState *m) {
-    s16 startYaw = m->faceAngle[1];
+    /*06*/ s16 startYaw = m->faceAngle[1];
 
     if (m->input & INPUT_A_PRESSED) {
         return set_mario_action(m, ACT_RIDING_SHELL_JUMP, 0);
@@ -1209,7 +1590,7 @@ s32 act_riding_shell_ground(struct MarioState *m) {
         if (m->forwardVel < 24.0f) {
             mario_set_forward_vel(m, 24.0f);
         }
-        return set_mario_action(m, ACT_CROUCH_SLIDE, 0);
+        return set_mario_action(m, ACT_DIVE_SLIDE, 0);
     }
 
     update_shell_speed(m);
@@ -1238,9 +1619,8 @@ s32 act_riding_shell_ground(struct MarioState *m) {
     }
 
     adjust_sound_for_speed(m);
-#ifdef VERSION_SH
-    reset_rumble_timers();
-#endif
+    
+
     return FALSE;
 }
 
@@ -1319,7 +1699,7 @@ s32 act_burning_ground(struct MarioState *m) {
         m->forwardVel = 48.0f;
     }
 
-    m->forwardVel = approach_f32(m->forwardVel, 32.0f, 4.0f, 1.0f);
+    m->forwardVel = approach_f32(m->forwardVel, 42.0f, 4.0f, 1.0f);
 
     if (m->input & INPUT_NONZERO_ANALOG) {
         m->faceAngle[1] =
@@ -1337,34 +1717,56 @@ s32 act_burning_ground(struct MarioState *m) {
 
     m->particleFlags |= PARTICLE_FIRE;
     play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
+	if (!(m->flags & MARIO_IS_SUPER))
+	{
+		if (gDialogHealthSystem == SONIC_HEALTH)
+		{
+                if (gMarioState->numCoins >= 50) {
+                    play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                    obj_spawn_yellow_coins(m->marioObj, 50);
+                    gMarioState->numCoins = 0;
+                    gHudDisplay.coins = 0;
+                } else {
+                    play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                    obj_spawn_yellow_coins(m->marioObj, gMarioState->numCoins);
+                    gMarioState->numCoins = 0;
+                    gHudDisplay.coins = 0;
+                }
+                if (gMarioState->numCoins == 0) {
+                    // m->health -= 100;
+                }
+		}
+		else
+		{
+			m->health -= 10;
+		}
+	}
+
+	if (m->health < 0x100 ) {
+		set_mario_action(m, ACT_STANDING_DEATH, 0);
+	}
+    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
 
-    m->health -= 10;
-    if (m->health < 0x100) {
-        set_mario_action(m, ACT_STANDING_DEATH, 0);
-    }
 
-    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
-#ifdef VERSION_SH
-    reset_rumble_timers();
-#endif
     return FALSE;
 }
 
 void tilt_body_butt_slide(struct MarioState *m) {
     s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
-    m->marioBodyState->torsoAngle[0] = (s32)(5461.3335f * m->intendedMag / 32.0f * coss(intendedDYaw));
-    m->marioBodyState->torsoAngle[2] = (s32)(-(5461.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
+    m->marioBodyState->torsoAngle[0] = (s32)(1961.3335f * m->intendedMag / 32.0f * coss(intendedDYaw));
+    m->marioBodyState->torsoAngle[2] = (s32)(-(1961.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
 }
 
 void common_slide_action(struct MarioState *m, u32 endAction, u32 airAction, s32 animation) {
-    Vec3f pos;
+    Vec3f val14;
 
-    vec3f_copy(pos, m->pos);
+
+    m->homingObj = NULL;
+
+    vec3f_copy(val14, m->pos);
     play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
 
-#ifdef VERSION_SH
-    reset_rumble_timers();
-#endif
+
 
     adjust_sound_for_speed(m);
 
@@ -1488,17 +1890,16 @@ s32 act_crouch_slide(struct MarioState *m) {
 
 s32 act_slide_kick_slide(struct MarioState *m) {
     if (m->input & INPUT_A_PRESSED) {
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
-        return set_jumping_action(m, ACT_FORWARD_ROLLOUT, 0);
-    }
 
+        return set_jumping_action(m, ACT_JUMP, 0);
+    }
+    m->actionTimer++;
     set_mario_animation(m, MARIO_ANIM_SLIDE_KICK);
     if (is_anim_at_end(m) && m->forwardVel < 1.0f) {
         return set_mario_action(m, ACT_SLIDE_KICK_SLIDE_STOP, 0);
     }
 
+
     update_sliding(m, 1.0f);
     switch (perform_ground_step(m)) {
         case GROUND_STEP_LEFT_GROUND:
@@ -1518,13 +1919,15 @@ s32 act_slide_kick_slide(struct MarioState *m) {
 }
 
 s32 stomach_slide_action(struct MarioState *m, u32 stopAction, u32 airAction, s32 animation) {
+
     if (m->actionTimer == 5) {
         if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
-#ifdef VERSION_SH
-            queue_rumble_data(5, 80);
-#endif
-            return drop_and_set_mario_action(
-                m, m->forwardVel >= 0.0f ? ACT_FORWARD_ROLLOUT : ACT_BACKWARD_ROLLOUT, 0);
+
+			if (m->forwardVel < 180)
+			{
+				return drop_and_set_mario_action(
+					m, m->forwardVel >= 0.0f ? ACT_JUMP : ACT_JUMP, 0);
+			}
         }
     } else {
         m->actionTimer++;
@@ -1539,8 +1942,13 @@ s32 stomach_slide_action(struct MarioState *m, u32 stopAction, u32 airAction, s3
 }
 
 s32 act_stomach_slide(struct MarioState *m) {
-    s32 cancel = stomach_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_SLIDE_DIVE);
+
+    s32 cancel = stomach_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_FORWARD_SPINNING);
     return cancel;
+	m->marioObj->header.gfx.animInfo.animAccel = 0x10000;
+
+    
+
 }
 
 s32 act_hold_stomach_slide(struct MarioState *m) {
@@ -1550,16 +1958,23 @@ s32 act_hold_stomach_slide(struct MarioState *m) {
         return drop_and_set_mario_action(m, ACT_STOMACH_SLIDE, 0);
     }
 
-    cancel = stomach_slide_action(m, ACT_DIVE_PICKING_UP, ACT_HOLD_FREEFALL, MARIO_ANIM_SLIDE_DIVE);
+    cancel = stomach_slide_action(m, ACT_DIVE_PICKING_UP, ACT_HOLD_FREEFALL, MARIO_ANIM_FORWARD_SPINNING);
     return cancel;
 }
 
 s32 act_dive_slide(struct MarioState *m) {
+    m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] + 650;
+	//m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] + 55;
+	//cur_obj_scale(0.9f);
+    if (check_kick_or_dive_in_air(m)) {
+        return TRUE;
+    }
+	m->marioObj->header.gfx.animInfo.animAccel = 0x10000 + 0x0200 * m->forwardVel;
+
     if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
-        return set_mario_action(m, m->forwardVel > 0.0f ? ACT_FORWARD_ROLLOUT : ACT_BACKWARD_ROLLOUT,
+
+
+        return set_mario_action(m, m->forwardVel > 0.0f ? ACT_JUMP : ACT_JUMP,
                                 0);
     }
 
@@ -1570,7 +1985,15 @@ s32 act_dive_slide(struct MarioState *m) {
     // mario_check_object_grab, and so will end up in the regular picking action,
     // rather than the picking up after dive action.
 
-    if (update_sliding(m, 8.0f) && is_anim_at_end(m)) {
+	if (m->forwardVel < 0.2f)
+	{
+		mario_set_forward_vel(m, 0.0f);
+		set_mario_action(m, ACT_IDLE, 0);
+	}
+
+		
+
+    if (update_sliding(m, 0.0f) && is_anim_at_end(m)) {
         mario_set_forward_vel(m, 0.0f);
         set_mario_action(m, ACT_STOMACH_SLIDE_STOP, 0);
     }
@@ -1581,12 +2004,12 @@ s32 act_dive_slide(struct MarioState *m) {
         return TRUE;
     }
 
-    common_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_DIVE);
+    common_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_FORWARD_SPINNING);
     return FALSE;
 }
 
 s32 common_ground_knockback_action(struct MarioState *m, s32 animation, s32 arg2, s32 arg3, s32 arg4) {
-    s32 animFrame;
+    s32 val04;
 
     if (arg3) {
         play_mario_heavy_landing_sound_once(m, SOUND_ACTION_TERRAIN_BODY_HIT_GROUND);
@@ -1609,8 +2032,8 @@ s32 common_ground_knockback_action(struct MarioState *m, s32 animation, s32 arg2
         m->forwardVel = -32.0f;
     }
 
-    animFrame = set_mario_animation(m, animation);
-    if (animFrame < arg2) {
+    val04 = set_mario_animation(m, animation);
+    if (val04 < arg2) {
         apply_landing_accel(m, 0.9f);
     } else if (m->forwardVel >= 0.0f) {
         mario_set_forward_vel(m, 0.1f);
@@ -1635,23 +2058,23 @@ s32 common_ground_knockback_action(struct MarioState *m, s32 animation, s32 arg2
         }
     }
 
-    return animFrame;
+    return val04;
 }
 
 s32 act_hard_backward_ground_kb(struct MarioState *m) {
-    s32 animFrame =
-        common_ground_knockback_action(m, MARIO_ANIM_FALL_OVER_BACKWARDS, 43, TRUE, m->actionArg);
-    if (animFrame == 43 && m->health < 0x100) {
+    s32 val04 =
+        common_ground_knockback_action(m, MARIO_ANIM_FALL_OVER_BACKWARDS, 0x2B, TRUE, m->actionArg);
+    if (val04 == 0x2B && m->health < 0x100) {
         set_mario_action(m, ACT_DEATH_ON_BACK, 0);
     }
 
 #ifndef VERSION_JP
-    if (animFrame == 54 && m->prevAction == ACT_SPECIAL_DEATH_EXIT) {
+    if (val04 == 0x36 && m->prevAction == ACT_SPECIAL_DEATH_EXIT) {
         play_sound(SOUND_MARIO_MAMA_MIA, m->marioObj->header.gfx.cameraToObject);
     }
 #endif
 
-    if (animFrame == 69) {
+    if (val04 == 0x45) {
         play_mario_landing_sound_once(m, SOUND_ACTION_TERRAIN_LANDING);
     }
 
@@ -1659,9 +2082,9 @@ s32 act_hard_backward_ground_kb(struct MarioState *m) {
 }
 
 s32 act_hard_forward_ground_kb(struct MarioState *m) {
-    s32 animFrame =
-        common_ground_knockback_action(m, MARIO_ANIM_LAND_ON_STOMACH, 21, TRUE, m->actionArg);
-    if (animFrame == 23 && m->health < 0x100) {
+
+    s32 val04 = common_ground_knockback_action(m, MARIO_ANIM_LAND_ON_STOMACH, 0x15, TRUE, m->actionArg);
+    if (val04 == 0x17 && m->health < 0x100) {
         set_mario_action(m, ACT_DEATH_ON_STOMACH, 0);
     }
 
@@ -1669,46 +2092,49 @@ s32 act_hard_forward_ground_kb(struct MarioState *m) {
 }
 
 s32 act_backward_ground_kb(struct MarioState *m) {
-    common_ground_knockback_action(m, MARIO_ANIM_BACKWARD_KB, 22, TRUE, m->actionArg);
+    common_ground_knockback_action(m, MARIO_ANIM_BACKWARD_KB, 0x16, TRUE, m->actionArg);
     return FALSE;
+	
 }
 
 s32 act_forward_ground_kb(struct MarioState *m) {
-    common_ground_knockback_action(m, MARIO_ANIM_FORWARD_KB, 20, TRUE, m->actionArg);
+    common_ground_knockback_action(m, MARIO_ANIM_FORWARD_KB, 0x14, TRUE, m->actionArg);
+	
     return FALSE;
 }
 
 s32 act_soft_backward_ground_kb(struct MarioState *m) {
-    common_ground_knockback_action(m, MARIO_ANIM_SOFT_BACK_KB, 100, FALSE, m->actionArg);
+	
+    common_ground_knockback_action(m, MARIO_ANIM_SOFT_BACK_KB, 0x64, FALSE, m->actionArg);
     return FALSE;
 }
 
 s32 act_soft_forward_ground_kb(struct MarioState *m) {
-    common_ground_knockback_action(m, MARIO_ANIM_SOFT_FRONT_KB, 100, FALSE, m->actionArg);
+	
+    common_ground_knockback_action(m, MARIO_ANIM_SOFT_FRONT_KB, 0x64, FALSE, m->actionArg);
     return FALSE;
 }
 
 s32 act_ground_bonk(struct MarioState *m) {
-    s32 animFrame =
-        common_ground_knockback_action(m, MARIO_ANIM_GROUND_BONK, 32, TRUE, m->actionArg);
-    if (animFrame == 32) {
+    s32 val04 = common_ground_knockback_action(m, MARIO_ANIM_GROUND_BONK, 0x20, TRUE, m->actionArg);
+    if (val04 == 0x20) {
         play_mario_landing_sound(m, SOUND_ACTION_TERRAIN_LANDING);
     }
     return FALSE;
 }
 
 s32 act_death_exit_land(struct MarioState *m) {
-    s32 animFrame;
+    s32 val04;
 
     apply_landing_accel(m, 0.9f);
     play_mario_heavy_landing_sound_once(m, SOUND_ACTION_TERRAIN_BODY_HIT_GROUND);
 
-    animFrame = set_mario_animation(m, MARIO_ANIM_FALL_OVER_BACKWARDS);
+    val04 = set_mario_animation(m, MARIO_ANIM_FALL_OVER_BACKWARDS);
 
-    if (animFrame == 54) {
+    if (val04 == 0x36) {
         play_sound(SOUND_MARIO_MAMA_MIA, m->marioObj->header.gfx.cameraToObject);
     }
-    if (animFrame == 68) {
+    if (val04 == 0x44) {
         play_mario_landing_sound(m, SOUND_ACTION_TERRAIN_LANDING);
     }
 
@@ -1725,6 +2151,7 @@ u32 common_landing_action(struct MarioState *m, s16 animation, u32 airAction) {
     if (m->input & INPUT_NONZERO_ANALOG) {
         apply_landing_accel(m, 0.98f);
     } else if (m->forwardVel >= 16.0f) {
+
         apply_slope_decel(m, 2.0f);
     } else {
         m->vel[1] = 0.0f;
@@ -1764,7 +2191,8 @@ s32 common_landing_cancels(struct MarioState *m, struct LandingAction *landingAc
         return mario_push_off_steep_floor(m, landingAction->verySteepAction, 0);
     }
 
-    m->doubleJumpTimer = landingAction->unk02;
+    //m->doubleJumpTimer = landingAction->unk02;
+
 
     if (should_begin_sliding(m)) {
         return set_mario_action(m, landingAction->slideAction, 0);
@@ -1790,6 +2218,7 @@ s32 common_landing_cancels(struct MarioState *m, struct LandingAction *landingAc
 }
 
 s32 act_jump_land(struct MarioState *m) {
+
     if (common_landing_cancels(m, &sJumpLandAction, set_jumping_action)) {
         return TRUE;
     }
@@ -1851,7 +2280,7 @@ s32 act_long_jump_land(struct MarioState *m) {
         m->forwardVel = 0.0f;
     }
 #endif
-
+    
     if (!(m->input & INPUT_Z_DOWN)) {
         m->input &= ~INPUT_A_PRESSED;
     }
@@ -1872,8 +2301,8 @@ s32 act_long_jump_land(struct MarioState *m) {
 }
 
 s32 act_double_jump_land(struct MarioState *m) {
-    if (common_landing_cancels(m, &sDoubleJumpLandAction, set_triple_jump_action)) {
-        return TRUE;
+    if (common_landing_cancels(m, &sDoubleJumpLandAction, set_jumping_action)) {
+        return FALSE;
     }
     common_landing_action(m, MARIO_ANIM_LAND_FROM_DOUBLE_JUMP, ACT_FREEFALL);
     return FALSE;
@@ -2023,6 +2452,7 @@ s32 mario_execute_moving_action(struct MarioState *m) {
         case ACT_QUICKSAND_JUMP_LAND:      cancel = act_quicksand_jump_land(m);      break;
         case ACT_HOLD_QUICKSAND_JUMP_LAND: cancel = act_hold_quicksand_jump_land(m); break;
         case ACT_LONG_JUMP_LAND:           cancel = act_long_jump_land(m);           break;
+		case ACT_SPINDASH:                 cancel = act_spindash(m);		     	 break;
     }
     /* clang-format on */
 
