diff a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c	(rejected hunks)
@@ -2,6 +2,7 @@
 
 #include "sm64.h"
 #include "area.h"
+#include "audio/data.h"
 #include "audio/external.h"
 #include "camera.h"
 #include "engine/graph_node.h"
@@ -13,6 +14,11 @@
 #include "mario_step.h"
 #include "save_file.h"
 #include "rumble_init.h"
+#include "ingame_menu.h"
+#include "level_update.h"
+#include "object_helpers.h"
+#include "sound_init.h"
+#include "seq_ids.h"
 
 void play_flip_sounds(struct MarioState *m, s16 frame1, s16 frame2, s16 frame3) {
     s32 animFrame = m->marioObj->header.gfx.animInfo.animFrame;
@@ -25,10 +31,13 @@ void play_far_fall_sound(struct MarioState *m) {
     u32 action = m->action;
     if (!(action & ACT_FLAG_INVULNERABLE) && action != ACT_TWIRLING && action != ACT_FLYING
         && !(m->flags & MARIO_UNKNOWN_18)) {
-        if (m->peakHeight - m->pos[1] > 1150.0f) {
-            play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
-            m->flags |= MARIO_UNKNOWN_18;
-        }
+		if (gDialogHealthSystem != SONIC_HEALTH)
+		{
+			if (m->peakHeight - m->pos[1] > 1150.0f) {
+				play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
+				m->flags |= MARIO_UNKNOWN_18;
+			}
+		}
     }
 }
 
@@ -49,9 +58,30 @@ s32 lava_boost_on_wall(struct MarioState *m) {
         m->forwardVel = 24.0f;
     }
 
-    if (!(m->flags & MARIO_METAL_CAP)) {
-        m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
-    }
+	if (!(m->flags & MARIO_METAL_CAP)) {
+		if (!(m->flags & MARIO_IS_SUPER))
+		{
+		if (gDialogHealthSystem != SONIC_HEALTH)
+		{
+			m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
+		}
+		else
+		{
+                    if (gMarioState->numCoins >= 50) {
+                        obj_spawn_yellow_coins(m->marioObj, 50);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    } else {
+                        obj_spawn_yellow_coins(m->marioObj, gMarioState->numCoins);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    }
+                    if (gMarioState->numCoins == 0) {
+                        m->health = 0xFF;
+                    }
+		}
+		}
+	}
 
     play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
     update_mario_sound_and_camera(m);
@@ -61,49 +91,69 @@ s32 lava_boost_on_wall(struct MarioState *m) {
 s32 check_fall_damage(struct MarioState *m, u32 hardFallAction) {
     f32 fallHeight;
     f32 damageHeight;
-
-    fallHeight = m->peakHeight - m->pos[1];
-
+	if (gDialogHealthSystem != SONIC_HEALTH )
+	{
+		if (!(m->flags & MARIO_IS_SUPER))
+	{
+		fallHeight = m->peakHeight - m->pos[1];
+	}
+	}
+	else
+	{
+		fallHeight = 0;
+	}
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wtype-limits"
 
     //! Never true
-    if (m->actionState == ACT_GROUND_POUND) {
-        damageHeight = 600.0f;
-    } else {
-        damageHeight = 1150.0f;
-    }
+	
+	
+		if (m->actionState == ACT_GROUND_POUND) {
+			damageHeight = 600.0f;
+		}
+		else {
+			damageHeight = 1150.0f;
+		}
 
 #pragma GCC diagnostic pop
 
-    if (m->action != ACT_TWIRLING && m->floor->type != SURFACE_BURNING) {
-        if (m->vel[1] < -55.0f) {
-            if (fallHeight > 3000.0f) {
-                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 16 : 24;
-#ifdef VERSION_SH
-                queue_rumble_data(5, 80);
-#endif
-                set_camera_shake_from_hit(SHAKE_FALL_DAMAGE);
-                play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
-                return drop_and_set_mario_action(m, hardFallAction, 4);
-            } else if (fallHeight > damageHeight && !mario_floor_is_slippery(m)) {
-                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 8 : 12;
-                m->squishTimer = 30;
-#ifdef VERSION_SH
-                queue_rumble_data(5, 80);
-#endif
-                set_camera_shake_from_hit(SHAKE_FALL_DAMAGE);
-                play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
-            }
-        }
-    }
+		if (m->action != ACT_TWIRLING && m->floor->type != SURFACE_BURNING) {
+			if (m->vel[1] < -55.0f) {
+				if (fallHeight > 3000.0f) {
+					m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 16 : 24;
 
-    return FALSE;
+					set_camera_shake_from_hit(SHAKE_FALL_DAMAGE);
+					play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
+					return drop_and_set_mario_action(m, hardFallAction, 4);
+				}
+				else if (fallHeight > damageHeight && !mario_floor_is_slippery(m)) {
+					m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 8 : 12;
+					m->squishTimer = 30;
+
+	
+					set_camera_shake_from_hit(SHAKE_FALL_DAMAGE);
+					play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
+				}
+			}
+		}
+
+		return FALSE;
+	
 }
 
 s32 check_kick_or_dive_in_air(struct MarioState *m) {
     if (m->input & INPUT_B_PRESSED) {
-        return set_mario_action(m, m->forwardVel > 28.0f ? ACT_DIVE : ACT_JUMP_KICK, 0);
+        if (m->action == ACT_DIVE_SLIDE)
+        {
+       //     m->forwardVel *= 4.4f;
+            play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_HAHA);
+            
+        return set_mario_action(m, m->forwardVel > 0.3f ? ACT_SLIDE_KICK_SLIDE : ACT_JUMP_KICK, 0);
+        }
+        else
+        {
+            return set_mario_action(m, m->forwardVel > 0.3f ? ACT_DIVE : ACT_JUMP_KICK, 0);
+        }
     }
     return FALSE;
 }
@@ -133,9 +183,8 @@ s32 check_fall_damage_or_get_stuck(struct MarioState *m, u32 hardFallAction) {
 #endif
         m->particleFlags |= PARTICLE_MIST_CIRCLE;
         drop_and_set_mario_action(m, ACT_FEET_STUCK_IN_GROUND, 0);
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
+ 
         return TRUE;
     }
 
@@ -180,33 +229,122 @@ s32 check_horizontal_wind(struct MarioState *m) {
 }
 
 void update_air_with_turn(struct MarioState *m) {
-    f32 dragThreshold;
-    s16 intendedDYaw;
-    f32 intendedMag;
+	f32 dragThreshold;
+	s16 intendedDYaw;
+	f32 intendedMag;
+    f32 homingDist;
+    f32 sp34;
+    f32 sp30;
+    f32 sp2C;
+    s16 sp2A;
+    struct Object *object;
+    object = 0;
+
+	if (m->homingObj == NULL)
+	{
+
+
+		if (!check_horizontal_wind(m)) {
+
+			dragThreshold = m->action == ACT_LONG_JUMP ? 48.0f : 32.0f;
+			m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
+
+			if (m->input & INPUT_NONZERO_ANALOG) {
+
+				intendedDYaw = m->intendedYaw - m->faceAngle[1];
+				intendedMag = m->intendedMag / 32.0f;
+
+				m->forwardVel += 1.5f * coss(intendedDYaw) * intendedMag;
+                m->faceAngle[1] += 512.0f * sins(intendedDYaw) * intendedMag;
+
+			}
+
+			//! Uncapped air speed. Net positive when moving forward.
+			if (m->forwardVel > dragThreshold) {
+				m->forwardVel -= 1.0f;
+			}
+			if (m->forwardVel < -16.0f) {
+				m->forwardVel += 2.0f;
+			}
+
+			m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
+			m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
+		}
+	}
+	else
+	{
+       
+        if (m->marioObj->collidedObjInteractTypes & INTERACT_BOUNCE_TOP) {
+            object = mario_get_collided_object(m, INTERACT_BOUNCE_TOP);
+        }
+        if (m->marioObj->collidedObjInteractTypes & INTERACT_HIT_FROM_BELOW) {
+           object = mario_get_collided_object(m, INTERACT_HIT_FROM_BELOW);
+        }
+            m->actionTimer++;
+           // if (m->homingObj->oDistanceToMario <= 800.0f)
+          //  { 
+                homingDist = lateral_dist_between_objects(gMarioState->marioObj, m->homingObj);
+                //BULLY
+           // }
+            /*
+            else
+            {
+                homingDist = 800.0f;
+            }
+                if (homingDist >= 800.0f)
+                {
+                    homingDist = 800.0f;
+                }
+                */
+
+                if (m->action == ACT_DIVE)
+                {
+                    
+                if (m->homingObj != object)
+                {
+                    
+                    set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+                    sp34 = m->homingObj->oPosX - m->pos[0];
+                    sp30 = m->homingObj->oPosY - m->pos[1] + 15.0f;
+                    sp2C = m->homingObj->oPosZ - m->pos[2];
+                    sp2A = atan2s(sqrtf(sqr(sp34) + sqr(sp2C)), sp30);
+
+
+                    m->faceAngle[1] = mario_obj_angle_to_object(m, m->homingObj);
+                    m->faceAngle[0] = approach_s16_symmetric(m->faceAngle[0], sp2A, 0x800);
+                    
+                    m->forwardVel = coss(m->faceAngle[0]) * 1.0f * (homingDist / 3.0f);
+                    if (m->forwardVel >= 300.0f || homingDist >= 500.0f)
+                    {
+                        m->forwardVel = 300.0f;
+                    }
 
-    if (!check_horizontal_wind(m)) {
-        dragThreshold = m->action == ACT_LONG_JUMP ? 48.0f : 32.0f;
-        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
+                    m->intendedYaw = m->faceAngle[1];
+                    m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
+                    m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
 
-        if (m->input & INPUT_NONZERO_ANALOG) {
-            intendedDYaw = m->intendedYaw - m->faceAngle[1];
-            intendedMag = m->intendedMag / 32.0f;
 
-            m->forwardVel += 1.5f * coss(intendedDYaw) * intendedMag;
-            m->faceAngle[1] += 512.0f * sins(intendedDYaw) * intendedMag;
-        }
+                    if (m->actionTimer > 120)
+                    {
+                        drop_and_set_mario_action(m, ACT_FREEFALL, 0);
+                    }
+                }
 
-        //! Uncapped air speed. Net positive when moving forward.
-        if (m->forwardVel > dragThreshold) {
-            m->forwardVel -= 1.0f;
-        }
-        if (m->forwardVel < -16.0f) {
-            m->forwardVel += 2.0f;
-        }
+			if (m->homingObj->oInteractStatus & INT_STATUS_INTERACTED)
+			{
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
 
-        m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
-        m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
-    }
+				m->homingObj = NULL;
+
+                   
+
+                m->faceAngle[1] = m->intendedYaw;
+				m->action = ACT_DOUBLE_JUMP;
+			}
+
+			
+		}
+	}
 }
 
 void update_air_without_turn(struct MarioState *m) {
@@ -222,9 +360,23 @@ void update_air_without_turn(struct MarioState *m) {
         if (m->input & INPUT_NONZERO_ANALOG) {
             intendedDYaw = m->intendedYaw - m->faceAngle[1];
             intendedMag = m->intendedMag / 32.0f;
-
-            m->forwardVel += intendedMag * coss(intendedDYaw) * 1.5f;
-            sidewaysSpeed = intendedMag * sins(intendedDYaw) * 10.0f;
+			if (m->action != ACT_JUMP)
+			{
+				m->forwardVel += intendedMag * coss(intendedDYaw) * 1.5f;
+				sidewaysSpeed = intendedMag * sins(intendedDYaw) * 10.0f;
+			}
+			else
+			{
+				if (m->forwardVel < 55.0f) {
+					m->forwardVel += intendedMag * coss(intendedDYaw) * 1.5f;
+					sidewaysSpeed = intendedMag * sins(intendedDYaw) * 10.0f;
+				}
+				else
+				{
+					m->forwardVel += intendedMag * coss(intendedDYaw) * 1.0f;
+					sidewaysSpeed = intendedMag * sins(intendedDYaw) * 5.0f;
+				}
+			}
         }
 
         //! Uncapped air speed. Net positive when moving forward.
@@ -324,6 +476,7 @@ void update_flying_pitch(struct MarioState *m) {
     } else {
         m->angleVel[0] = approach_s32(m->angleVel[0], 0, 0x40, 0x40);
     }
+ 
 }
 
 void update_flying(struct MarioState *m) {
@@ -331,6 +484,16 @@ void update_flying(struct MarioState *m) {
 
     update_flying_pitch(m);
     update_flying_yaw(m);
+    if (!(m->flags & MARIO_IS_SUPER ))
+    {
+        set_mario_animation(m, MARIO_ANIM_WING_CAP_FLY);
+    }
+
+	if (m->flags & MARIO_IS_SUPER && m->forwardVel < 800.0f)
+	{
+		m->forwardVel += 0.6f;
+	}
+
 
     m->forwardVel -= 2.0f * ((f32) m->faceAngle[0] / 0x4000) + 0.1f;
     m->forwardVel -= 0.5f * (1.0f - coss(m->angleVel[1]));
@@ -338,14 +501,25 @@ void update_flying(struct MarioState *m) {
     if (m->forwardVel < 0.0f) {
         m->forwardVel = 0.0f;
     }
+	if (!(m->flags & MARIO_IS_SUPER))
+	{
+		if (m->forwardVel > 16.0f) {
+			m->faceAngle[0] += (m->forwardVel - 32.0f) * 6.0f;
+		}
+		else if (m->forwardVel > 4.0f) {
+			m->faceAngle[0] += (m->forwardVel - 32.0f) * 10.0f;
+		}
+		else {
+			m->faceAngle[0] -= 0x400;
+		}
+	}
+	else
+	{
+		if (m->forwardVel < 4.0f) {
+			m->faceAngle[0] += (m->forwardVel - 32.0f) * 10.0f;
+		}
+	}
 
-    if (m->forwardVel > 16.0f) {
-        m->faceAngle[0] += (m->forwardVel - 32.0f) * 6.0f;
-    } else if (m->forwardVel > 4.0f) {
-        m->faceAngle[0] += (m->forwardVel - 32.0f) * 10.0f;
-    } else {
-        m->faceAngle[0] -= 0x400;
-    }
 
     m->faceAngle[0] += m->angleVel[0];
 
@@ -385,9 +559,7 @@ u32 common_air_action_step(struct MarioState *m, u32 landAction, s32 animation,
             set_mario_animation(m, animation);
 
             if (m->forwardVel > 16.0f) {
-#ifdef VERSION_SH
-                queue_rumble_data(5, 40);
-#endif
+             
                 mario_bonk_reflection(m, FALSE);
                 m->faceAngle[1] += 0x8000;
 
@@ -440,18 +612,64 @@ u32 common_air_action_step(struct MarioState *m, u32 landAction, s32 animation,
 }
 
 s32 act_jump(struct MarioState *m) {
-    if (check_kick_or_dive_in_air(m)) {
-        return TRUE;
+	
+	m->faceAngle[1] = m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x1000, 0x1000);
+
+	if (m->actionTimer > 7)
+	{
+		m->actionTimer = 0;
+	}
+	m->actionTimer++;
+	if (check_kick_or_dive_in_air(m)) {
+		return TRUE;
+	}
+
+	if (m->input & INPUT_Z_PRESSED) {
+		return set_mario_action(m, ACT_GROUND_POUND, 0);
+	}
+	
+    play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, 0);
+    common_air_action_step(m, ACT_JUMP_LAND, MARIO_ANIM_FORWARD_SPINNING,
+                           AIR_STEP_CHECK_LEDGE_GRAB | AIR_STEP_CHECK_HANG);
+    return FALSE;
+}
+
+s32 act_transform(struct MarioState *m) {
+	m->actionTimer += 1;
+	set_mario_animation(m, MARIO_ANIM_START_FORWARD_SPINNING);
+	if (is_anim_past_end(m)) {
+		drop_and_set_mario_action(m, ACT_FREEFALL, 0);
+	}
+    if (m->actionTimer > 0 && m->actionTimer < 16)
+    {
+    }
+    if (m->actionTimer > 3 && m->actionTimer < 7)
+    {
+        m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
     }
 
-    if (m->input & INPUT_Z_PRESSED) {
-        return set_mario_action(m, ACT_GROUND_POUND, 0);
+    if (m->actionTimer > 7 && m->actionTimer < 18)
+    {
+        m->marioBodyState->eyeState = MARIO_EYES_CLOSED;
     }
 
-    play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, 0);
-    common_air_action_step(m, ACT_JUMP_LAND, MARIO_ANIM_SINGLE_JUMP,
-                           AIR_STEP_CHECK_LEDGE_GRAB | AIR_STEP_CHECK_HANG);
-    return FALSE;
+	if (m->actionTimer == 18)
+	{
+		play_cap_music(SEQUENCE_ARGS(4, SEQ_SUPER));
+		//gMarioState->isSuper = 1;
+		m->flags |= MARIO_IS_SUPER;
+		//gMarioState->flags = MARIO_IS_SUPER;
+        play_mario_sound(m, SOUND_ACTION_THROW, SOUND_MARIO_OKEY_DOKEY);
+        //play_mario_sound(m, SOUND_ACTION_THROW, SOUND_MARIO_OKEY_DOKEY);
+       // play_sound_if_no_flag(m, SOUND_ACTION_THROW, MARIO_ACTION_SOUND_PLAYED);
+		//play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
+	}
+
+
+
+	m->pos[1] = m->pos[1];
+	m->pos[2] = m->pos[2];
+	m->pos[0] = m->pos[0];
 }
 
 s32 act_double_jump(struct MarioState *m) {
@@ -459,6 +677,19 @@ s32 act_double_jump(struct MarioState *m) {
         ? MARIO_ANIM_DOUBLE_JUMP_RISE
         : MARIO_ANIM_DOUBLE_JUMP_FALL;
 
+    update_air_with_turn(m);
+
+        
+    
+
+    m->forwardVel = 50.0f;
+	if (m->forwardVel >= 50.0f)
+	{
+		m->forwardVel = 50.0f;
+	}
+
+
+
     if (check_kick_or_dive_in_air(m)) {
         return TRUE;
     }
@@ -493,11 +724,9 @@ s32 act_triple_jump(struct MarioState *m) {
 #endif
 
     common_air_action_step(m, ACT_TRIPLE_JUMP_LAND, MARIO_ANIM_TRIPLE_JUMP, 0);
-#ifdef VERSION_SH
     if (m->action == ACT_TRIPLE_JUMP_LAND) {
-        queue_rumble_data(5, 40);
+
     }
-#endif
     play_flip_sounds(m, 2, 8, 20);
     return FALSE;
 }
@@ -508,19 +737,22 @@ s32 act_backflip(struct MarioState *m) {
     }
 
     play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_YAH_WAH_HOO);
-    common_air_action_step(m, ACT_BACKFLIP_LAND, MARIO_ANIM_BACKFLIP, 0);
-#ifdef VERSION_SH
+    common_air_action_step(m, ACT_BACKFLIP_LAND, MARIO_ANIM_FORWARD_SPINNING, 0);
+
     if (m->action == ACT_BACKFLIP_LAND) {
-        queue_rumble_data(5, 40);
+
     }
-#endif
     play_flip_sounds(m, 2, 3, 17);
     return FALSE;
 }
 
 s32 act_freefall(struct MarioState *m) {
     s32 animation;
-
+    //limits fall speed after roll
+    if (m->forwardVel >= 130.0f && m->prevAction == ACT_DIVE_SLIDE)
+    {
+        m->forwardVel = 130.0f;
+    }
     if (m->input & INPUT_B_PRESSED) {
         return set_mario_action(m, ACT_DIVE, 0);
     }
@@ -604,7 +836,7 @@ s32 act_side_flip(struct MarioState *m) {
         m->marioObj->header.gfx.angle[1] += 0x8000;
     }
 
-    // This must be one line to match on -O2
+    // (this need to be on one line to match on PAL)
     // clang-format off
     if (m->marioObj->header.gfx.animInfo.animFrame == 6) play_sound(SOUND_ACTION_SIDE_FLIP_UNK, m->marioObj->header.gfx.cameraToObject);
     // clang-format on
@@ -641,11 +873,10 @@ s32 act_long_jump(struct MarioState *m) {
     }
 
     common_air_action_step(m, ACT_LONG_JUMP_LAND, animation, AIR_STEP_CHECK_LEDGE_GRAB);
-#ifdef VERSION_SH
+
     if (m->action == ACT_LONG_JUMP_LAND) {
-        queue_rumble_data(5, 40);
+  
     }
-#endif
     return FALSE;
 }
 
@@ -718,14 +949,33 @@ s32 act_twirling(struct MarioState *m) {
     return FALSE;
 }
 
+
+
+
 s32 act_dive(struct MarioState *m) {
+
+
+	if ((m->flags & MARIO_WING_CAP) ) {
+		set_mario_action(m, ACT_FLYING, 0);
+	}
     if (m->actionArg == 0) {
         play_mario_sound(m, SOUND_ACTION_THROW, SOUND_MARIO_HOOHOO);
     } else {
         play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, 0);
     }
+	//m->particleFlags |= PARTICLE_SPARKLES;
 
-    set_mario_animation(m, MARIO_ANIM_DIVE);
+if (!(m->flags & MARIO_IS_SUPER))
+{
+	cur_obj_set_model(MODEL_SONIC_BALL);
+	m->particleFlags |= PARTICLE_SONIC_TRAIL;
+}
+else
+{
+	cur_obj_set_model(MODEL_SUPER_BALL);
+    m->particleFlags |= PARTICLE_SUPER_TRAIL;
+}
+    set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING);
     if (mario_check_object_grab(m)) {
         mario_grab_used_object(m);
         m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
@@ -734,34 +984,23 @@ s32 act_dive(struct MarioState *m) {
         }
     }
 
-    update_air_without_turn(m);
+    update_air_with_turn(m);
 
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_NONE:
-            if (m->vel[1] < 0.0f && m->faceAngle[0] > -0x2AAA) {
-                m->faceAngle[0] -= 0x200;
-                if (m->faceAngle[0] < -0x2AAA) {
-                    m->faceAngle[0] = -0x2AAA;
-                }
-            }
-            m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
             break;
 
         case AIR_STEP_LANDED:
             if (should_get_stuck_in_ground(m) && m->faceAngle[0] == -0x2AAA) {
-#ifdef VERSION_SH
-                queue_rumble_data(5, 80);
-#endif
-#ifdef VERSION_JP
-                play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
-#else
+       
+
                 play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
-#endif
+
                 m->particleFlags |= PARTICLE_MIST_CIRCLE;
                 drop_and_set_mario_action(m, ACT_HEAD_STUCK_IN_GROUND, 0);
             } else if (!check_fall_damage(m, ACT_HARD_FORWARD_GROUND_KB)) {
                 if (m->heldObj == NULL) {
-                    set_mario_action(m, ACT_DIVE_SLIDE, 0);
+                    set_mario_action(m, ACT_WALKING, 0);
                 } else {
                     set_mario_action(m, ACT_DIVE_PICKING_UP, 0);
                 }
@@ -828,7 +1067,7 @@ s32 act_water_jump(struct MarioState *m) {
     switch (perform_air_step(m, AIR_STEP_CHECK_LEDGE_GRAB)) {
         case AIR_STEP_LANDED:
             set_mario_action(m, ACT_JUMP_LAND, 0);
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            //set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
             break;
 
         case AIR_STEP_HIT_WALL:
@@ -840,7 +1079,7 @@ s32 act_water_jump(struct MarioState *m) {
             set_mario_animation(m, MARIO_ANIM_IDLE_ON_LEDGE);
 #endif
             set_mario_action(m, ACT_LEDGE_GRAB, 0);
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            //set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
             break;
 
         case AIR_STEP_HIT_LAVA_WALL:
@@ -917,20 +1156,22 @@ s32 act_ground_pound(struct MarioState *m) {
 
     play_sound_if_no_flag(m, SOUND_ACTION_THROW, MARIO_ACTION_SOUND_PLAYED);
 
-    if (m->actionState == 0) {
+    if (m->actionState != 0) {
         if (m->actionTimer < 10) {
             yOffset = 20 - 2 * m->actionTimer;
             if (m->pos[1] + yOffset + 160.0f < m->ceilHeight) {
                 m->pos[1] += yOffset;
+
                 m->peakHeight = m->pos[1];
                 vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
             }
         }
 
-        m->vel[1] = -50.0f;
+        m->vel[1] = -80.0f;
+		
         mario_set_forward_vel(m, 0.0f);
 
-        set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_START_GROUND_POUND
+        set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_FORWARD_SPINNING
                                                  : MARIO_ANIM_TRIPLE_JUMP_GROUND_POUND);
         if (m->actionTimer == 0) {
             play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
@@ -942,14 +1183,28 @@ s32 act_ground_pound(struct MarioState *m) {
             m->actionState = 1;
         }
     } else {
-        set_mario_animation(m, MARIO_ANIM_GROUND_POUND);
+		m->vel[1] = -50.0f;
+		if (!(m->flags & MARIO_IS_SUPER))
+		{
+			cur_obj_set_model(MODEL_SONIC_BALL);
+			m->particleFlags |= PARTICLE_SONIC_TRAIL;
+
+		}
+		else
+		{
+			cur_obj_set_model(MODEL_SUPER_BALL);
+			m->particleFlags |= PARTICLE_SUPER_TRAIL;
+		}
+
+		//m->marioObj->header.gfx.pos[1] = m->marioObj->header.gfx.pos[1] + 50;
+		m->marioObj->header.gfx.animInfo.animAccel = 0x30000;
+
+        set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING);
 
         stepResult = perform_air_step(m, 0);
         if (stepResult == AIR_STEP_LANDED) {
             if (should_get_stuck_in_ground(m)) {
-#ifdef VERSION_SH
-                queue_rumble_data(5, 80);
-#endif
+        
 #ifdef VERSION_JP
                 play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
 #else
@@ -958,7 +1213,7 @@ s32 act_ground_pound(struct MarioState *m) {
                 m->particleFlags |= PARTICLE_MIST_CIRCLE;
                 set_mario_action(m, ACT_BUTT_STUCK_IN_GROUND, 0);
             } else {
-                play_mario_heavy_landing_sound(m, SOUND_ACTION_TERRAIN_HEAVY_LANDING);
+				play_sound(SOUND_OBJ_WATER_BOMB_BOUNCING, m->marioObj->header.gfx.cameraToObject);
                 if (!check_fall_damage(m, ACT_HARD_BACKWARD_GROUND_KB)) {
                     m->particleFlags |= PARTICLE_MIST_CIRCLE | PARTICLE_HORIZONTAL_STAR;
                     set_mario_action(m, ACT_GROUND_POUND_LAND, 0);
@@ -993,14 +1248,21 @@ s32 act_burning_jump(struct MarioState *m) {
     play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
 
     m->marioObj->oMarioBurnTimer += 3;
+	if (gDialogHealthSystem != SONIC_HEALTH)
+	{
+
+		
+	if (!(m->flags & MARIO_IS_SUPER))
+		{
+			m->health -= 10;
+		}
+			if (m->health < 0x100) {
+				m->health = 0xFF;
+			}
+		
+
+	}
 
-    m->health -= 10;
-    if (m->health < 0x100) {
-        m->health = 0xFF;
-    }
-#ifdef VERSION_SH
-    reset_rumble_timers();
-#endif
     return FALSE;
 }
 
@@ -1020,9 +1282,8 @@ s32 act_burning_fall(struct MarioState *m) {
     if (m->health < 0x100) {
         m->health = 0xFF;
     }
-#ifdef VERSION_SH
-    reset_rumble_timers();
-#endif
+
+
     return FALSE;
 }
 
@@ -1071,9 +1332,7 @@ s32 act_crazy_box_bounce(struct MarioState *m) {
                 m->heldObj = NULL;
                 set_mario_action(m, ACT_STOMACH_SLIDE, 0);
             }
-#ifdef VERSION_SH
-            queue_rumble_data(5, 80);
-#endif
+ ;
             m->particleFlags |= PARTICLE_MIST_CIRCLE;
             break;
 
@@ -1151,7 +1410,7 @@ s32 check_wall_kick(struct MarioState *m) {
 
 s32 act_backward_air_kb(struct MarioState *m) {
     if (check_wall_kick(m)) {
-        return TRUE;
+        return 1;
     }
 
 #ifndef VERSION_JP
@@ -1165,7 +1424,7 @@ s32 act_backward_air_kb(struct MarioState *m) {
 
 s32 act_forward_air_kb(struct MarioState *m) {
     if (check_wall_kick(m)) {
-        return TRUE;
+        return 1;
     }
 
 #ifndef VERSION_JP
@@ -1242,7 +1501,7 @@ s32 act_thrown_forward(struct MarioState *m) {
 
 s32 act_soft_bonk(struct MarioState *m) {
     if (check_wall_kick(m)) {
-        return TRUE;
+        return 1;
     }
 
 #ifndef VERSION_JP
@@ -1341,9 +1600,10 @@ s32 act_air_hit_wall(struct MarioState *m) {
     //! Missing return statement. The returned value is the result of the call
     // to set_mario_animation. In practice, this value is nonzero.
     // This results in this action "cancelling" into itself. It is supposed to
-    // execute on two frames, but instead it executes twice on the same frame.
+    // execute three times, each on a separate frame, but instead it executes
+    // three times on the same frame.
     // This results in firsties only being possible for a single frame, instead
-    // of two.
+    // of three.
 }
 
 s32 act_forward_rollout(struct MarioState *m) {
@@ -1505,14 +1765,11 @@ s32 act_hold_butt_slide_air(struct MarioState *m) {
 }
 
 s32 act_lava_boost(struct MarioState *m) {
-#ifdef VERSION_SH
     if (!(m->flags & MARIO_MARIO_SOUND_PLAYED)) {
         play_sound_if_no_flag(m, SOUND_MARIO_ON_FIRE, MARIO_MARIO_SOUND_PLAYED);
-        queue_rumble_data(5, 80);
+  
     }
-#else
     play_sound_if_no_flag(m, SOUND_MARIO_ON_FIRE, MARIO_MARIO_SOUND_PLAYED);
-#endif
 
     if (!(m->input & INPUT_NONZERO_ANALOG)) {
         m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
@@ -1525,13 +1782,35 @@ s32 act_lava_boost(struct MarioState *m) {
             if (m->floor->type == SURFACE_BURNING) {
                 m->actionState = 0;
                 if (!(m->flags & MARIO_METAL_CAP)) {
-                    m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
+					if (!(m->flags & MARIO_IS_SUPER))
+					{
+						if (gDialogHealthSystem != SONIC_HEALTH)
+						{
+							m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
+						}
+						else
+						{
+                                                    if (gMarioState->numCoins >= 50) {
+                                                        play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                                                        obj_spawn_yellow_coins(m->marioObj, 50);
+                                                        gMarioState->numCoins = 0;
+                                                        gHudDisplay.coins = 0;
+                                                    } else {
+                                                        obj_spawn_yellow_coins(m->marioObj,
+                                                                               gMarioState->numCoins);
+                                                        gMarioState->numCoins = 0;
+                                                        gHudDisplay.coins = 0;
+                                                    }
+
+                                                    if (gMarioState->numCoins == 0) {
+                                                        m->health = 0xFF;
+                                                    }
+						}
+					}
                 }
                 m->vel[1] = 84.0f;
                 play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
-#ifdef VERSION_SH
-                queue_rumble_data(5, 80);
-#endif
+               
             } else {
                 play_mario_heavy_landing_sound(m, SOUND_ACTION_TERRAIN_BODY_HIT_GROUND);
                 if (m->actionState < 2 && m->vel[1] < 0.0f) {
@@ -1567,42 +1846,32 @@ s32 act_lava_boost(struct MarioState *m) {
     }
 
     m->marioBodyState->eyeState = MARIO_EYES_DEAD;
-#ifdef VERSION_SH
-    reset_rumble_timers();
-#endif
+
+
     return FALSE;
 }
 
 s32 act_slide_kick(struct MarioState *m) {
     if (m->actionState == 0 && m->actionTimer == 0) {
-        play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_HOOHOO);
+        play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_HAHA);
         set_mario_animation(m, MARIO_ANIM_SLIDE_KICK);
     }
 
-    if (++(m->actionTimer) > 30 && m->pos[1] - m->floorHeight > 500.0f) {
-        return set_mario_action(m, ACT_FREEFALL, 2);
-    }
 
-    update_air_without_turn(m);
+
+
 
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_NONE:
             if (m->actionState == 0) {
-                m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
-                if (m->marioObj->header.gfx.angle[0] > 0x1800) {
-                    m->marioObj->header.gfx.angle[0] = 0x1800;
-                }
+                set_mario_action(m, ACT_SLIDE_KICK_SLIDE, 0);
             }
             break;
 
         case AIR_STEP_LANDED:
-            if (m->actionState == 0 && m->vel[1] < 0.0f) {
-                m->vel[1] = -m->vel[1] / 2.0f;
-                m->actionState = 1;
-                m->actionTimer = 0;
-            } else {
+
                 set_mario_action(m, ACT_SLIDE_KICK_SLIDE, 0);
-            }
+
             play_mario_landing_sound(m, SOUND_ACTION_TERRAIN_LANDING);
             break;
 
@@ -1670,7 +1939,8 @@ s32 act_shot_from_cannon(struct MarioState *m) {
 
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_NONE:
-            set_mario_animation(m, MARIO_ANIM_AIRBORNE_ON_STOMACH);
+			set_mario_anim_with_accel(m, MARIO_ANIM_FORWARD_SPINNING, 0x20000);
+            //set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING);
             m->faceAngle[0] = atan2s(m->forwardVel, m->vel[1]);
             m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
             break;
@@ -1678,10 +1948,18 @@ s32 act_shot_from_cannon(struct MarioState *m) {
         case AIR_STEP_LANDED:
             set_mario_action(m, ACT_DIVE_SLIDE, 0);
             m->faceAngle[0] = 0;
+#ifndef BETTERCAMERA
             set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
-#ifdef VERSION_SH
-            queue_rumble_data(5, 80);
+#else
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAMERA_MODE_NEWCAM;
+                gLakituState.mode = CAMERA_MODE_NEWCAM;
+            }
 #endif
+          
             break;
 
         case AIR_STEP_HIT_WALL:
@@ -1694,7 +1972,17 @@ s32 act_shot_from_cannon(struct MarioState *m) {
 
             m->particleFlags |= PARTICLE_VERTICAL_STAR;
             set_mario_action(m, ACT_BACKWARD_AIR_KB, 0);
+#ifndef BETTERCAMERA
             set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+#else
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAMERA_MODE_NEWCAM;
+                gLakituState.mode = CAMERA_MODE_NEWCAM;
+            }
+#endif
             break;
 
         case AIR_STEP_HIT_LAVA_WALL:
@@ -1713,38 +2001,83 @@ s32 act_shot_from_cannon(struct MarioState *m) {
     if (m->vel[1] > 0.0f) {
         m->particleFlags |= PARTICLE_DUST;
     }
-#ifdef VERSION_SH
-    reset_rumble_timers();
-#endif
+
+    
     return FALSE;
 }
 
 s32 act_flying(struct MarioState *m) {
     s16 startPitch = m->faceAngle[0];
+	f32 val14;
+    val14 = (s32)(m->forwardVel / 10.5f * 0x10000);
 
     if (m->input & INPUT_Z_PRESSED) {
         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
+#ifndef BETTERCAMERA
             set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+#else
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAMERA_MODE_NEWCAM;
+                gLakituState.mode = CAMERA_MODE_NEWCAM;
+            }
+#endif
         }
         return set_mario_action(m, ACT_GROUND_POUND, 1);
     }
 
     if (!(m->flags & MARIO_WING_CAP)) {
         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
+#ifndef BETTERCAMERA
             set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+#else
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAMERA_MODE_NEWCAM;
+                gLakituState.mode = CAMERA_MODE_NEWCAM;
+            }
+#endif
         }
         return set_mario_action(m, ACT_FREEFALL, 0);
     }
 
     if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
+#ifndef BETTERCAMERA
         set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
+#else
+        if (newcam_active == 0)
+            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+        else
+        {
+            m->area->camera->mode = CAMERA_MODE_NEWCAM;
+            gLakituState.mode = CAMERA_MODE_NEWCAM;
+        }
+#endif
     }
 
     if (m->actionState == 0) {
         if (m->actionArg == 0) {
-            set_mario_animation(m, MARIO_ANIM_FLY_FROM_CANNON);
+			if (m->flags & MARIO_IS_SUPER)
+			{
+				set_mario_anim_with_accel(m, MARIO_ANIM_BEND_KNESS_RIDING_SHELL, val14);
+			}
+			else
+			{
+				set_mario_animation(m, MARIO_ANIM_WING_CAP_FLY);
+			}
         } else {
-            set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING_FLIP);
+			if (m->flags & MARIO_IS_SUPER)
+			{
+				set_mario_anim_with_accel(m, MARIO_ANIM_BEND_KNESS_RIDING_SHELL, val14);
+			}
+			else
+			{
+				set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING_FLIP);
+			}
             if (m->marioObj->header.gfx.animInfo.animFrame == 1) {
                 play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
             }
@@ -1756,7 +2089,18 @@ s32 act_flying(struct MarioState *m) {
                 m->actionArg = 1;
             }
 
-            set_mario_animation(m, MARIO_ANIM_WING_CAP_FLY);
+            
+
+			if (m->flags & MARIO_IS_SUPER)
+			{
+                
+				set_mario_anim_with_accel(m, MARIO_ANIM_BEND_KNESS_RIDING_SHELL, val14);
+			}
+			else
+			{
+				set_mario_animation(m, MARIO_ANIM_WING_CAP_FLY);
+			}
+
             m->actionState = 1;
         }
     }
@@ -1798,7 +2142,17 @@ s32 act_flying(struct MarioState *m) {
 
                 m->particleFlags |= PARTICLE_VERTICAL_STAR;
                 set_mario_action(m, ACT_BACKWARD_AIR_KB, 0);
+#ifndef BETTERCAMERA
+            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+#else
+            if (newcam_active == 0)
                 set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAMERA_MODE_NEWCAM;
+                gLakituState.mode = CAMERA_MODE_NEWCAM;
+            }
+#endif
             } else {
                 if (m->actionTimer++ == 0) {
                     play_sound(SOUND_ACTION_HIT, m->marioObj->header.gfx.cameraToObject);
@@ -1822,10 +2176,16 @@ s32 act_flying(struct MarioState *m) {
             lava_boost_on_wall(m);
             break;
     }
-
-    if (m->faceAngle[0] > 0x800 && m->forwardVel >= 48.0f) {
-        m->particleFlags |= PARTICLE_DUST;
-    }
+	if (m->forwardVel >= 48.0f)
+	{
+		if (m->faceAngle[0] > 0x800 || m->flags & MARIO_IS_SUPER) {
+			if (m->forwardVel >= 90.0f)
+			{
+				m->forwardVel = 90.0f;
+			}
+			m->particleFlags |= PARTICLE_DUST;
+		}
+	}
 
     if (startPitch <= 0 && m->faceAngle[0] > 0 && m->forwardVel >= 48.0f) {
         play_sound(SOUND_ACTION_FLYING_FAST, m->marioObj->header.gfx.cameraToObject);
@@ -1833,9 +2193,7 @@ s32 act_flying(struct MarioState *m) {
         play_sound(SOUND_MARIO_YAHOO_WAHA_YIPPEE + ((gAudioRandom % 5) << 16),
                    m->marioObj->header.gfx.cameraToObject);
 #endif
-#ifdef VERSION_SH
-        queue_rumble_data(50, 40);
-#endif
+      
     }
 
     play_sound(SOUND_MOVING_FLYING, m->marioObj->header.gfx.cameraToObject);
@@ -1849,9 +2207,7 @@ s32 act_riding_hoot(struct MarioState *m) {
         m->usedObj->oHootMarioReleaseTime = gGlobalTimer;
 
         play_sound_if_no_flag(m, SOUND_MARIO_UH, MARIO_MARIO_SOUND_PLAYED);
-#ifdef VERSION_SH
-        queue_rumble_data(4, 40);
-#endif
+     
         return set_mario_action(m, ACT_FREEFALL, 0);
     }
 
@@ -1879,7 +2235,17 @@ s32 act_flying_triple_jump(struct MarioState *m) {
 #ifndef VERSION_JP
     if (m->input & (INPUT_B_PRESSED | INPUT_Z_PRESSED)) {
         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
+#ifndef BETTERCAMERA
             set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+#else
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAMERA_MODE_NEWCAM;
+                gLakituState.mode = CAMERA_MODE_NEWCAM;
+            }
+#endif
         }
         if (m->input & INPUT_B_PRESSED) {
             return set_mario_action(m, ACT_DIVE, 0);
@@ -1907,9 +2273,7 @@ s32 act_flying_triple_jump(struct MarioState *m) {
 
         if (is_anim_past_end(m)) {
             set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING);
-#ifdef VERSION_SH
-            queue_rumble_data(8, 80);
-#endif
+       
             m->actionState = 1;
         }
     }
@@ -1920,7 +2284,17 @@ s32 act_flying_triple_jump(struct MarioState *m) {
 
     if (m->vel[1] < 4.0f) {
         if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
+#ifndef BETTERCAMERA
             set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
+#else
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAMERA_MODE_NEWCAM;
+                gLakituState.mode = CAMERA_MODE_NEWCAM;
+            }
+#endif
         }
 
         if (m->forwardVel < 32.0f) {
@@ -1930,9 +2304,11 @@ s32 act_flying_triple_jump(struct MarioState *m) {
         set_mario_action(m, ACT_FLYING, 1);
     }
 
+#ifndef BETTERCAMERA
     if (m->actionTimer++ == 10 && m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
         set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
     }
+#endif
 
     update_air_without_turn(m);
 
@@ -1970,9 +2346,7 @@ s32 act_vertical_wind(struct MarioState *m) {
         set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING_FLIP);
         if (m->marioObj->header.gfx.animInfo.animFrame == 1) {
             play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
-#ifdef VERSION_SH
-            queue_rumble_data(8, 80);
-#endif
+           
         }
 
         if (is_anim_past_end(m)) {
@@ -2112,6 +2486,7 @@ s32 mario_execute_airborne_action(struct MarioState *m) {
         case ACT_RIDING_HOOT:          cancel = act_riding_hoot(m);          break;
         case ACT_TOP_OF_POLE_JUMP:     cancel = act_top_of_pole_jump(m);     break;
         case ACT_VERTICAL_WIND:        cancel = act_vertical_wind(m);        break;
+		case ACT_TRANSFORM:			   cancel = act_transform(m);			 break;
     }
     /* clang-format on */
 
