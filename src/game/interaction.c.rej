diff a/src/game/interaction.c b/src/game/interaction.c	(rejected hunks)
@@ -23,6 +23,7 @@
 #include "sm64.h"
 #include "sound_init.h"
 #include "rumble_init.h"
+#include "game/ingame_menu.h"
 
 #define INT_GROUND_POUND_OR_TWIRL (1 << 0) // 0x01
 #define INT_PUNCH                 (1 << 1) // 0x02
@@ -46,39 +47,39 @@
 
 u8 sDelayInvincTimer;
 s16 sInvulnerable;
-u32 interact_coin(struct MarioState *, u32, struct Object *);
-u32 interact_water_ring(struct MarioState *, u32, struct Object *);
-u32 interact_star_or_key(struct MarioState *, u32, struct Object *);
-u32 interact_bbh_entrance(struct MarioState *, u32, struct Object *);
-u32 interact_warp(struct MarioState *, u32, struct Object *);
-u32 interact_warp_door(struct MarioState *, u32, struct Object *);
-u32 interact_door(struct MarioState *, u32, struct Object *);
-u32 interact_cannon_base(struct MarioState *, u32, struct Object *);
-u32 interact_igloo_barrier(struct MarioState *, u32, struct Object *);
-u32 interact_tornado(struct MarioState *, u32, struct Object *);
-u32 interact_whirlpool(struct MarioState *, u32, struct Object *);
-u32 interact_strong_wind(struct MarioState *, u32, struct Object *);
-u32 interact_flame(struct MarioState *, u32, struct Object *);
-u32 interact_snufit_bullet(struct MarioState *, u32, struct Object *);
-u32 interact_clam_or_bubba(struct MarioState *, u32, struct Object *);
-u32 interact_bully(struct MarioState *, u32, struct Object *);
-u32 interact_shock(struct MarioState *, u32, struct Object *);
-u32 interact_mr_blizzard(struct MarioState *, u32, struct Object *);
-u32 interact_hit_from_below(struct MarioState *, u32, struct Object *);
-u32 interact_bounce_top(struct MarioState *, u32, struct Object *);
-u32 interact_unknown_08(struct MarioState *, u32, struct Object *);
-u32 interact_damage(struct MarioState *, u32, struct Object *);
-u32 interact_breakable(struct MarioState *, u32, struct Object *);
-u32 interact_koopa_shell(struct MarioState *, u32, struct Object *);
-u32 interact_pole(struct MarioState *, u32, struct Object *);
-u32 interact_hoot(struct MarioState *, u32, struct Object *);
-u32 interact_cap(struct MarioState *, u32, struct Object *);
-u32 interact_grabbable(struct MarioState *, u32, struct Object *);
-u32 interact_text(struct MarioState *, u32, struct Object *);
+u32 interact_coin(struct MarioState*, u32, struct Object*);
+u32 interact_water_ring(struct MarioState*, u32, struct Object*);
+u32 interact_star_or_key(struct MarioState*, u32, struct Object*);
+u32 interact_bbh_entrance(struct MarioState*, u32, struct Object*);
+u32 interact_warp(struct MarioState*, u32, struct Object*);
+u32 interact_warp_door(struct MarioState*, u32, struct Object*);
+u32 interact_door(struct MarioState*, u32, struct Object*);
+u32 interact_cannon_base(struct MarioState*, u32, struct Object*);
+u32 interact_igloo_barrier(struct MarioState*, u32, struct Object*);
+u32 interact_tornado(struct MarioState*, u32, struct Object*);
+u32 interact_whirlpool(struct MarioState*, u32, struct Object*);
+u32 interact_strong_wind(struct MarioState*, u32, struct Object*);
+u32 interact_flame(struct MarioState*, u32, struct Object*);
+u32 interact_snufit_bullet(struct MarioState*, u32, struct Object*);
+u32 interact_clam_or_bubba(struct MarioState*, u32, struct Object*);
+u32 interact_bully(struct MarioState*, u32, struct Object*);
+u32 interact_shock(struct MarioState*, u32, struct Object*);
+u32 interact_mr_blizzard(struct MarioState*, u32, struct Object*);
+u32 interact_hit_from_below(struct MarioState*, u32, struct Object*);
+u32 interact_bounce_top(struct MarioState*, u32, struct Object*);
+u32 interact_unknown_08(struct MarioState*, u32, struct Object*);
+u32 interact_damage(struct MarioState*, u32, struct Object*);
+u32 interact_breakable(struct MarioState*, u32, struct Object*);
+u32 interact_koopa_shell(struct MarioState*, u32, struct Object*);
+u32 interact_pole(struct MarioState*, u32, struct Object*);
+u32 interact_hoot(struct MarioState*, u32, struct Object*);
+u32 interact_cap(struct MarioState*, u32, struct Object*);
+u32 interact_grabbable(struct MarioState*, u32, struct Object*);
+u32 interact_text(struct MarioState*, u32, struct Object*);
 
 struct InteractionHandler {
     u32 interactType;
-    u32 (*handler)(struct MarioState *, u32, struct Object *);
+    u32(*handler)(struct MarioState*, u32, struct Object*);
 };
 
 static struct InteractionHandler sInteractionHandlers[] = {
@@ -113,6 +114,7 @@ static struct InteractionHandler sInteractionHandlers[] = {
     { INTERACT_CAP,            interact_cap },
     { INTERACT_GRABBABLE,      interact_grabbable },
     { INTERACT_TEXT,           interact_text },
+
 };
 
 static u32 sForwardKnockbackActions[][3] = {
@@ -132,29 +134,31 @@ static u8 sJustTeleported = FALSE;
 static u8 sPssSlideStarted = FALSE;
 
 /**
- * Returns the type of cap Mario is wearing.
+ * Returns the type of hat Mario is wearing.
  */
-u32 get_mario_cap_flag(struct Object *capObject) {
-    const BehaviorScript *script = virtual_to_segmented(0x13, capObject->behavior);
+u32 get_mario_cap_flag(struct Object* capObject) {
+    void* script = virtual_to_segmented(0x13, capObject->behavior);
 
     if (script == bhvNormalCap) {
         return MARIO_NORMAL_CAP;
-    } else if (script == bhvMetalCap) {
+    }
+    else if (script == bhvMetalCap) {
         return MARIO_METAL_CAP;
-    } else if (script == bhvWingCap) {
+    }
+    else if (script == bhvWingCap) {
         return MARIO_WING_CAP;
-    } else if (script == bhvVanishCap) {
+    }
+    else if (script == bhvVanishCap) {
         return MARIO_VANISH_CAP;
     }
 
     return 0;
 }
-
 /**
  * Returns true if the passed in object has a moving angle yaw
  * in the angular range given towards Mario.
  */
-u32 object_facing_mario(struct MarioState *m, struct Object *o, s16 angleRange) {
+u32 object_facing_mario(struct MarioState* m, struct Object* o, s16 angleRange) {
     f32 dx = m->pos[0] - o->oPosX;
     f32 dz = m->pos[2] - o->oPosZ;
 
@@ -168,7 +172,7 @@ u32 object_facing_mario(struct MarioState *m, struct Object *o, s16 angleRange)
     return FALSE;
 }
 
-s16 mario_obj_angle_to_object(struct MarioState *m, struct Object *o) {
+s16 mario_obj_angle_to_object(struct MarioState* m, struct Object* o) {
     f32 dx = o->oPosX - m->pos[0];
     f32 dz = o->oPosZ - m->pos[2];
 
@@ -179,7 +183,7 @@ s16 mario_obj_angle_to_object(struct MarioState *m, struct Object *o) {
  * Determines Mario's interaction with a given object depending on their proximity,
  * action, speed, and position.
  */
-u32 determine_interaction(struct MarioState *m, struct Object *o) {
+u32 determine_interaction(struct MarioState* m, struct Object* o) {
     u32 interaction = 0;
     u32 action = m->action;
 
@@ -205,11 +209,13 @@ u32 determine_interaction(struct MarioState *m, struct Object *o) {
                     interaction = INT_TRIP;
                 }
             }
-        } else if (action == ACT_GROUND_POUND || action == ACT_TWIRLING) {
+        }
+        else if (action == ACT_GROUND_POUND || action == ACT_TWIRLING) {
             if (m->vel[1] < 0.0f) {
                 interaction = INT_GROUND_POUND_OR_TWIRL;
             }
-        } else if (action == ACT_GROUND_POUND_LAND || action == ACT_TWIRL_LAND) {
+        }
+        else if (action == ACT_GROUND_POUND_LAND || action == ACT_TWIRL_LAND) {
             // Neither ground pounding nor twirling change Mario's vertical speed on landing.,
             // so the speed check is nearly always true (perhaps not if you land while going upwards?)
             // Additionally, actionState it set on each first thing in their action, so this is
@@ -217,13 +223,19 @@ u32 determine_interaction(struct MarioState *m, struct Object *o) {
             if (m->vel[1] < 0.0f && m->actionState == 0) {
                 interaction = INT_GROUND_POUND_OR_TWIRL;
             }
-        } else if (action == ACT_SLIDE_KICK || action == ACT_SLIDE_KICK_SLIDE) {
-            interaction = INT_SLIDE_KICK;
-        } else if (action & ACT_FLAG_RIDING_SHELL) {
+        }
+        else if (action == ACT_SLIDE_KICK || action == ACT_SLIDE_KICK_SLIDE) {
             interaction = INT_FAST_ATTACK_OR_SHELL;
-        } else if (m->forwardVel <= -26.0f || 26.0f <= m->forwardVel) {
+
+        }
+        else if (action & ACT_FLAG_RIDING_SHELL || m->flags & MARIO_IS_SUPER) {
             interaction = INT_FAST_ATTACK_OR_SHELL;
         }
+
+        else if ((m->forwardVel <= -26.0f || 26.0f <= m->forwardVel) && action != ACT_DIVE) {
+            interaction = INT_FAST_ATTACK_OR_SHELL;
+
+        }
     }
 
     // Prior to this, the interaction type could be overwritten. This requires, however,
@@ -234,50 +246,58 @@ u32 determine_interaction(struct MarioState *m, struct Object *o) {
             if (m->pos[1] > o->oPosY) {
                 interaction = INT_HIT_FROM_ABOVE;
             }
-        } else {
+        }
+        else {
             if (m->pos[1] < o->oPosY) {
                 interaction = INT_HIT_FROM_BELOW;
             }
         }
     }
 
+    if (action == ACT_DIVE)
+    {
+        interaction = INT_HIT_FROM_ABOVE;
+    }
+
     return interaction;
 }
 
 /**
  * Sets the interaction types for INT_STATUS_INTERACTED, INT_STATUS_WAS_ATTACKED
  */
-u32 attack_object(struct Object *o, s32 interaction) {
+u32 attack_object(struct Object* o, s32 interaction) {
     u32 attackType = 0;
 
     switch (interaction) {
-        case INT_GROUND_POUND_OR_TWIRL:
-            attackType = ATTACK_GROUND_POUND_OR_TWIRL;
-            break;
-        case INT_PUNCH:
-            attackType = ATTACK_PUNCH;
-            break;
-        case INT_KICK:
-        case INT_TRIP:
-            attackType = ATTACK_KICK_OR_TRIP;
-            break;
-        case INT_SLIDE_KICK:
-        case INT_FAST_ATTACK_OR_SHELL:
+    case INT_GROUND_POUND_OR_TWIRL:
+        attackType = ATTACK_GROUND_POUND_OR_TWIRL;
+        break;
+    case INT_PUNCH:
+        attackType = ATTACK_PUNCH;
+        break;
+    case INT_KICK:
+    case INT_TRIP:
+        attackType = ATTACK_KICK_OR_TRIP;
+        break;
+    case INT_SLIDE_KICK:
+        attackType = ATTACK_FAST_ATTACK;
+        break;
+    case INT_FAST_ATTACK_OR_SHELL:
             attackType = ATTACK_FAST_ATTACK;
-            break;
-        case INT_HIT_FROM_ABOVE:
-            attackType = ATTACK_FROM_ABOVE;
-            break;
-        case INT_HIT_FROM_BELOW:
-            attackType = ATTACK_FROM_BELOW;
-            break;
+        break;
+    case INT_HIT_FROM_ABOVE:
+        attackType = ATTACK_FROM_ABOVE;
+        break;
+    case INT_HIT_FROM_BELOW:
+        attackType = ATTACK_FROM_BELOW;
+        break;
     }
 
     o->oInteractStatus = attackType + (INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
     return attackType;
 }
 
-void mario_stop_riding_object(struct MarioState *m) {
+void mario_stop_riding_object(struct MarioState* m) {
     if (m->riddenObj != NULL) {
         m->riddenObj->oInteractStatus = INT_STATUS_STOP_RIDING;
         stop_shell_music();
@@ -285,14 +305,14 @@ void mario_stop_riding_object(struct MarioState *m) {
     }
 }
 
-void mario_grab_used_object(struct MarioState *m) {
+void mario_grab_used_object(struct MarioState* m) {
     if (m->heldObj == NULL) {
         m->heldObj = m->usedObj;
         obj_set_held_state(m->heldObj, bhvCarrySomething3);
     }
 }
 
-void mario_drop_held_object(struct MarioState *m) {
+void mario_drop_held_object(struct MarioState* m) {
     if (m->heldObj != NULL) {
         if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
             stop_shell_music();
@@ -313,7 +333,7 @@ void mario_drop_held_object(struct MarioState *m) {
     }
 }
 
-void mario_throw_held_object(struct MarioState *m) {
+void mario_throw_held_object(struct MarioState* m) {
     if (m->heldObj != NULL) {
         if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
             stop_shell_music();
@@ -331,7 +351,7 @@ void mario_throw_held_object(struct MarioState *m) {
     }
 }
 
-void mario_stop_riding_and_holding(struct MarioState *m) {
+void mario_stop_riding_and_holding(struct MarioState* m) {
     mario_drop_held_object(m);
     mario_stop_riding_object(m);
 
@@ -341,40 +361,18 @@ void mario_stop_riding_and_holding(struct MarioState *m) {
     }
 }
 
-u32 does_mario_have_normal_cap_on_head(struct MarioState *m) {
-    return (m->flags & (MARIO_CAPS | MARIO_CAP_ON_HEAD)) == (MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
+u32 does_mario_have_hat(struct MarioState* m) {
+    return (m->flags & MARIO_CAP_FLAGS) == (MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
 }
 
-void mario_blow_off_cap(struct MarioState *m, f32 capSpeed) {
-    struct Object *capObject;
+void mario_blow_off_cap(struct MarioState* m, f32 capSpeed) {
+    struct Object* capObject;
 
-    if (does_mario_have_normal_cap_on_head(m)) {
-        save_file_set_cap_pos(m->pos[0], m->pos[1], m->pos[2]);
 
-        m->flags &= ~(MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
-
-        capObject = spawn_object(m->marioObj, MODEL_MARIOS_CAP, bhvNormalCap);
-
-        capObject->oPosY += (m->action & ACT_FLAG_SHORT_HITBOX) ? 120.0f : 180.0f;
-        capObject->oForwardVel = capSpeed;
-        capObject->oMoveAngleYaw = (s16)(m->faceAngle[1] + 0x400);
-
-        if (m->forwardVel < 0.0f) {
-            capObject->oMoveAngleYaw = (s16)(capObject->oMoveAngleYaw + 0x8000);
-        }
-    }
 }
 
 u32 mario_lose_cap_to_enemy(u32 arg) {
-    u32 wasWearingCap = FALSE;
-
-    if (does_mario_have_normal_cap_on_head(gMarioState)) {
-        save_file_set_flags(arg == 1 ? SAVE_FLAG_CAP_ON_KLEPTO : SAVE_FLAG_CAP_ON_UKIKI);
-        gMarioState->flags &= ~(MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
-        wasWearingCap = TRUE;
-    }
 
-    return wasWearingCap;
 }
 
 void mario_retrieve_cap(void) {
@@ -384,14 +382,15 @@ void mario_retrieve_cap(void) {
     gMarioState->flags |= MARIO_NORMAL_CAP | MARIO_CAP_IN_HAND;
 }
 
-u32 able_to_grab_object(struct MarioState *m, UNUSED struct Object *o) {
+u32 able_to_grab_object(struct MarioState* m, UNUSED struct Object* o) {
     u32 action = m->action;
 
     if (action == ACT_DIVE_SLIDE || action == ACT_DIVE) {
         if (!(o->oInteractionSubtype & INT_SUBTYPE_GRABS_MARIO)) {
             return TRUE;
         }
-    } else if (action == ACT_PUNCHING || action == ACT_MOVE_PUNCHING) {
+    }
+    else if (action == ACT_PUNCHING || action == ACT_MOVE_PUNCHING) {
         if (m->actionArg < 2) {
             return TRUE;
         }
@@ -400,9 +399,9 @@ u32 able_to_grab_object(struct MarioState *m, UNUSED struct Object *o) {
     return FALSE;
 }
 
-struct Object *mario_get_collided_object(struct MarioState *m, u32 interactType) {
+struct Object* mario_get_collided_object(struct MarioState* m, u32 interactType) {
     s32 i;
-    struct Object *object;
+    struct Object* object;
 
     for (i = 0; i < m->marioObj->numCollidedObjs; i++) {
         object = m->marioObj->collidedObjs[i];
@@ -415,9 +414,13 @@ struct Object *mario_get_collided_object(struct MarioState *m, u32 interactType)
     return NULL;
 }
 
-u32 mario_check_object_grab(struct MarioState *m) {
+u32 mario_homing(struct MarioState* m) {
+
+}
+
+u32 mario_check_object_grab(struct MarioState* m) {
     u32 result = FALSE;
-    const BehaviorScript *script;
+    void* script;
 
     if (m->input & INPUT_INTERACT_OBJ_GRABBABLE) {
         script = virtual_to_segmented(0x13, m->interactObj->behavior);
@@ -429,9 +432,10 @@ u32 mario_check_object_grab(struct MarioState *m) {
                 m->usedObj = m->interactObj;
                 result = set_mario_action(m, ACT_PICKING_UP_BOWSER, 0);
             }
-        } else {
+        }
+        else {
             s16 facingDYaw = mario_obj_angle_to_object(m, m->interactObj) - m->faceAngle[1];
-            if (facingDYaw >= -0x2AAA && facingDYaw <= 0x2AAA) {
+            if (facingDYaw >= -0x8AAA && facingDYaw <= 0x8AAA) {
                 m->usedObj = m->interactObj;
 
                 if (!(m->action & ACT_FLAG_AIR)) {
@@ -447,7 +451,7 @@ u32 mario_check_object_grab(struct MarioState *m) {
     return result;
 }
 
-u32 bully_knock_back_mario(struct MarioState *mario) {
+u32 bully_knock_back_mario(struct MarioState* mario) {
     struct BullyCollisionData marioData;
     struct BullyCollisionData bullyData;
     s16 newMarioYaw;
@@ -457,7 +461,7 @@ u32 bully_knock_back_mario(struct MarioState *mario) {
 
     u32 bonkAction = 0;
 
-    struct Object *bully = mario->interactObj;
+    struct Object* bully = mario->interactObj;
 
     //! Conversion ratios multiply to more than 1 (could allow unbounded speed
     // with bonk cancel - but this isn't important for regular bully battery)
@@ -465,14 +469,15 @@ u32 bully_knock_back_mario(struct MarioState *mario) {
     f32 marioToBullyRatio = 53.0f / bully->hitboxRadius;
 
     init_bully_collision_data(&marioData, mario->pos[0], mario->pos[2], mario->forwardVel,
-                              mario->faceAngle[1], bullyToMarioRatio, 52.0f);
+        mario->faceAngle[1], bullyToMarioRatio, 52.0f);
 
     init_bully_collision_data(&bullyData, bully->oPosX, bully->oPosZ, bully->oForwardVel,
-                              bully->oMoveAngleYaw, marioToBullyRatio, bully->hitboxRadius + 2.0f);
+        bully->oMoveAngleYaw, marioToBullyRatio, bully->hitboxRadius + 2.0f);
 
     if (mario->forwardVel != 0.0f) {
         transfer_bully_speed(&marioData, &bullyData);
-    } else {
+    }
+    else {
         transfer_bully_speed(&bullyData, &marioData);
     }
 
@@ -498,13 +503,16 @@ u32 bully_knock_back_mario(struct MarioState *mario) {
 
         if (mario->action & ACT_FLAG_AIR) {
             bonkAction = ACT_BACKWARD_AIR_KB;
-        } else {
+        }
+        else {
             bonkAction = ACT_SOFT_BACKWARD_GROUND_KB;
         }
-    } else {
+    }
+    else {
         if (mario->action & ACT_FLAG_AIR) {
             bonkAction = ACT_FORWARD_AIR_KB;
-        } else {
+        }
+        else {
             bonkAction = ACT_SOFT_FORWARD_GROUND_KB;
         }
     }
@@ -512,7 +520,7 @@ u32 bully_knock_back_mario(struct MarioState *mario) {
     return bonkAction;
 }
 
-void bounce_off_object(struct MarioState *m, struct Object *o, f32 velY) {
+void bounce_off_object(struct MarioState* m, struct Object* o, f32 velY) {
     m->pos[1] = o->oPosY + o->hitboxHeight;
     m->vel[1] = velY;
 
@@ -521,12 +529,12 @@ void bounce_off_object(struct MarioState *m, struct Object *o, f32 velY) {
     play_sound(SOUND_ACTION_BOUNCE_OFF_OBJECT, m->marioObj->header.gfx.cameraToObject);
 }
 
-void hit_object_from_below(struct MarioState *m, UNUSED struct Object *o) {
+void hit_object_from_below(struct MarioState* m, UNUSED struct Object* o) {
     m->vel[1] = 0.0f;
     set_camera_shake_from_hit(SHAKE_HIT_FROM_BELOW);
 }
 
-static u32 unused_determine_knockback_action(struct MarioState *m) {
+static u32 unused_determine_knockback_action(struct MarioState* m) {
     u32 bonkAction;
     s16 angleToObject = mario_obj_angle_to_object(m, m->interactObj);
     s16 facingDYaw = angleToObject - m->faceAngle[1];
@@ -541,14 +549,17 @@ static u32 unused_determine_knockback_action(struct MarioState *m) {
         m->forwardVel *= -1.0f;
         if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
             bonkAction = ACT_BACKWARD_AIR_KB;
-        } else {
+        }
+        else {
             bonkAction = ACT_SOFT_BACKWARD_GROUND_KB;
         }
-    } else {
+    }
+    else {
         m->faceAngle[1] += 0x8000;
         if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
             bonkAction = ACT_FORWARD_AIR_KB;
-        } else {
+        }
+        else {
             bonkAction = ACT_SOFT_FORWARD_GROUND_KB;
         }
     }
@@ -556,7 +567,7 @@ static u32 unused_determine_knockback_action(struct MarioState *m) {
     return bonkAction;
 }
 
-u32 determine_knockback_action(struct MarioState *m, UNUSED s32 arg) {
+u32 determine_knockback_action(struct MarioState* m, UNUSED s32 arg) {
     u32 bonkAction;
 
     s16 terrainIndex = 0; // 1 = air, 2 = water, 0 = default
@@ -568,15 +579,18 @@ u32 determine_knockback_action(struct MarioState *m, UNUSED s32 arg) {
 
     if (m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER)) {
         terrainIndex = 2;
-    } else if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
+    }
+    else if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
         terrainIndex = 1;
     }
 
     if (remainingHealth < 0x100) {
         strengthIndex = 2;
-    } else if (m->interactObj->oDamageOrCoinValue >= 4) {
+    }
+    else if (m->interactObj->oDamageOrCoinValue >= 4) {
         strengthIndex = 2;
-    } else if (m->interactObj->oDamageOrCoinValue >= 2) {
+    }
+    else if (m->interactObj->oDamageOrCoinValue >= 2) {
         strengthIndex = 1;
     }
 
@@ -591,12 +605,14 @@ u32 determine_knockback_action(struct MarioState *m, UNUSED s32 arg) {
             if (m->vel[1] < 20.0f) {
                 m->vel[1] = 20.0f;
             }
-        } else {
+        }
+        else {
             if (m->vel[1] > 0.0f) {
                 m->vel[1] = 0.0f;
             }
         }
-    } else {
+    }
+    else {
         if (m->forwardVel < 16.0f) {
             mario_set_forward_vel(m, 16.0f);
         }
@@ -605,7 +621,8 @@ u32 determine_knockback_action(struct MarioState *m, UNUSED s32 arg) {
     if (-0x4000 <= facingDYaw && facingDYaw <= 0x4000) {
         m->forwardVel *= -1.0f;
         bonkAction = sBackwardKnockbackActions[terrainIndex][strengthIndex];
-    } else {
+    }
+    else {
         m->faceAngle[1] += 0x8000;
         bonkAction = sForwardKnockbackActions[terrainIndex][strengthIndex];
     }
@@ -613,7 +630,7 @@ u32 determine_knockback_action(struct MarioState *m, UNUSED s32 arg) {
     return bonkAction;
 }
 
-void push_mario_out_of_object(struct MarioState *m, struct Object *o, f32 padding) {
+void push_mario_out_of_object(struct MarioState* m, struct Object* o, f32 padding) {
     f32 minDistance = o->hitboxRadius + m->marioObj->hitboxRadius + padding;
 
     f32 offsetX = m->pos[0] - o->oPosX;
@@ -621,14 +638,15 @@ void push_mario_out_of_object(struct MarioState *m, struct Object *o, f32 paddin
     f32 distance = sqrtf(offsetX * offsetX + offsetZ * offsetZ);
 
     if (distance < minDistance) {
-        struct Surface *floor;
+        struct Surface* floor;
         s16 pushAngle;
         f32 newMarioX;
         f32 newMarioZ;
 
         if (distance == 0.0f) {
             pushAngle = m->faceAngle[1];
-        } else {
+        }
+        else {
             pushAngle = atan2s(offsetZ, offsetX);
         }
 
@@ -647,7 +665,7 @@ void push_mario_out_of_object(struct MarioState *m, struct Object *o, f32 paddin
     }
 }
 
-void bounce_back_from_attack(struct MarioState *m, u32 interaction) {
+void bounce_back_from_attack(struct MarioState* m, u32 interaction) {
     if (interaction & (INT_PUNCH | INT_KICK | INT_TRIP)) {
         if (m->action == ACT_PUNCHING) {
             m->action = ACT_MOVE_PUNCHING;
@@ -655,7 +673,8 @@ void bounce_back_from_attack(struct MarioState *m, u32 interaction) {
 
         if (m->action & ACT_FLAG_AIR) {
             mario_set_forward_vel(m, -16.0f);
-        } else {
+        }
+        else {
             mario_set_forward_vel(m, -48.0f);
         }
 
@@ -668,7 +687,7 @@ void bounce_back_from_attack(struct MarioState *m, u32 interaction) {
     }
 }
 
-u32 should_push_or_pull_door(struct MarioState *m, struct Object *o) {
+u32 should_push_or_pull_door(struct MarioState* m, struct Object* o) {
     f32 dx = o->oPosX - m->pos[0];
     f32 dz = o->oPosZ - m->pos[2];
 
@@ -677,40 +696,78 @@ u32 should_push_or_pull_door(struct MarioState *m, struct Object *o) {
     return (dYaw >= -0x4000 && dYaw <= 0x4000) ? 0x00000001 : 0x00000002;
 }
 
-u32 take_damage_from_interact_object(struct MarioState *m) {
+u32 take_damage_from_interact_object(struct MarioState* m) {
     s32 shake;
     s32 damage = m->interactObj->oDamageOrCoinValue;
+    if (!(m->flags & MARIO_IS_SUPER))
+    {
+        if (gDialogHealthSystem != SONIC_HEALTH)
+        {
+            if (damage >= 4) {
+                shake = SHAKE_LARGE_DAMAGE;
+            }
+            else if (damage >= 2) {
+                shake = SHAKE_MED_DAMAGE;
+            }
+            else {
+                shake = SHAKE_SMALL_DAMAGE;
+            }
 
-    if (damage >= 4) {
-        shake = SHAKE_LARGE_DAMAGE;
-    } else if (damage >= 2) {
-        shake = SHAKE_MED_DAMAGE;
-    } else {
-        shake = SHAKE_SMALL_DAMAGE;
-    }
+            if (!(m->flags & MARIO_CAP_ON_HEAD)) {
+                damage += (damage + 1) / 2;
+            }
 
-    if (!(m->flags & MARIO_CAP_ON_HEAD)) {
-        damage += (damage + 1) / 2;
-    }
+            if ((m->flags & MARIO_METAL_CAP) || (m->flags & MARIO_IS_SUPER)) {
 
-    if (m->flags & MARIO_METAL_CAP) {
-        damage = 0;
-    }
+                damage = 0;
+            }
 
-    m->hurtCounter += 4 * damage;
 
-#ifdef VERSION_SH
-    queue_rumble_data(5, 80);
-#endif
-    set_camera_shake_from_hit(shake);
 
+            m->hurtCounter += 4 * damage;
+        }
+    }
+    if (!(m->flags & MARIO_METAL_CAP))
+    {
+        if (!(m->flags & MARIO_IS_SUPER))
+        {
+            if (gDialogHealthSystem == SONIC_HEALTH)
+            {
+                if (gMarioState->numCoins > 0)
+                {
+                    damage = 0;
+                    shake = SHAKE_MED_DAMAGE;
+                    if (gMarioState->numCoins >= 50) {
+                        play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                        obj_spawn_yellow_coins(m->marioObj, 50);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    }
+                    else {
+                        play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                        obj_spawn_yellow_coins(m->marioObj, gMarioState->numCoins);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    }
+                }
+                else
+                {
+                    shake = SHAKE_LARGE_DAMAGE;
+                    m->health = 0xFF;
+                    m->hurtCounter += 4 * damage;
+                }
+            }
+        }
+    }
+
+    set_camera_shake_from_hit(shake);
     return damage;
 }
 
-u32 take_damage_and_knock_back(struct MarioState *m, struct Object *o) {
+u32 take_damage_and_knock_back(struct MarioState* m, struct Object* o) {
     u32 damage;
 
-    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
+    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP) && !(m->flags & MARIO_IS_SUPER)
         && !(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         o->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_ATTACKED_MARIO;
         m->interactObj = o;
@@ -727,45 +784,55 @@ u32 take_damage_and_knock_back(struct MarioState *m, struct Object *o) {
 
         update_mario_sound_and_camera(m);
         return drop_and_set_mario_action(m, determine_knockback_action(m, o->oDamageOrCoinValue),
-                                         damage);
+            damage);
     }
 
     return FALSE;
 }
 
-void reset_mario_pitch(struct MarioState *m) {
+void reset_mario_pitch(struct MarioState* m) {
     if (m->action == ACT_WATER_JUMP || m->action == ACT_SHOT_FROM_CANNON || m->action == ACT_FLYING) {
         set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
         m->faceAngle[0] = 0;
     }
 }
 
-u32 interact_coin(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_coin(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     m->numCoins += o->oDamageOrCoinValue;
     m->healCounter += 4 * o->oDamageOrCoinValue;
 
     o->oInteractStatus = INT_STATUS_INTERACTED;
-
+    //add 100 coins
     if (COURSE_IS_MAIN_COURSE(gCurrCourseNum) && m->numCoins - o->oDamageOrCoinValue < 100
         && m->numCoins >= 100) {
-        bhv_spawn_star_no_level_exit(6);
+        if (count_objects_with_behavior(bhvSpawnedStarNoLevelExit) < 1) {
+            if (m->coinstartotal > 6)
+            { 
+            bhv_spawn_star_no_level_exit(6);
+            }
+            else
+            {
+                bhv_spawn_emerald_no_level_exit(6, m->coinstartotal);
+            }
+        }
     }
-#ifdef VERSION_SH
+
     if (o->oDamageOrCoinValue >= 2) {
-        queue_rumble_data(5, 80);
+
     }
-#endif
 
     return FALSE;
 }
 
-u32 interact_water_ring(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_water_ring(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     m->healCounter += 4 * o->oDamageOrCoinValue;
+    m->drownTimer = 0;
+    stop_drown_music();
     o->oInteractStatus = INT_STATUS_INTERACTED;
     return FALSE;
 }
 
-u32 interact_star_or_key(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_star_or_key(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 starIndex;
     u32 starGrabAction = ACT_STAR_DANCE_EXIT;
     u32 noExit = (o->oInteractionSubtype & INT_SUBTYPE_NO_EXIT) != 0;
@@ -773,9 +840,7 @@ u32 interact_star_or_key(struct MarioState *m, UNUSED u32 interactType, struct O
 
     if (m->health >= 0x100) {
         mario_stop_riding_and_holding(m);
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
 
         if (!noExit) {
             m->hurtCounter = 0;
@@ -821,6 +886,7 @@ u32 interact_star_or_key(struct MarioState *m, UNUSED u32 interactType, struct O
         play_sound(SOUND_MENU_STAR_SOUND, m->marioObj->header.gfx.cameraToObject);
 #ifndef VERSION_JP
         update_mario_sound_and_camera(m);
+        // func_802521A0
 #endif
 
         if (grandStar) {
@@ -833,7 +899,7 @@ u32 interact_star_or_key(struct MarioState *m, UNUSED u32 interactType, struct O
     return FALSE;
 }
 
-u32 interact_bbh_entrance(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_bbh_entrance(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (m->action != ACT_BBH_ENTER_SPIN && m->action != ACT_BBH_ENTER_JUMP) {
         mario_stop_riding_and_holding(m);
 
@@ -851,7 +917,7 @@ u32 interact_bbh_entrance(struct MarioState *m, UNUSED u32 interactType, struct
     return FALSE;
 }
 
-u32 interact_warp(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_warp(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 action;
 
     if (o->oInteractionSubtype & INT_SUBTYPE_FADING_WARP) {
@@ -860,7 +926,8 @@ u32 interact_warp(struct MarioState *m, UNUSED u32 interactType, struct Object *
         if (action == ACT_TELEPORT_FADE_IN) {
             sJustTeleported = TRUE;
 
-        } else if (!sJustTeleported) {
+        }
+        else if (!sJustTeleported) {
             if (action == ACT_IDLE || action == ACT_PANTING || action == ACT_STANDING_AGAINST_WALL
                 || action == ACT_CROUCHING) {
                 m->interactObj = o;
@@ -870,26 +937,21 @@ u32 interact_warp(struct MarioState *m, UNUSED u32 interactType, struct Object *
                 return set_mario_action(m, ACT_TELEPORT_FADE_OUT, 0);
             }
         }
-    } else {
+    }
+    else {
         if (m->action != ACT_EMERGE_FROM_PIPE) {
             o->oInteractStatus = INT_STATUS_INTERACTED;
             m->interactObj = o;
             m->usedObj = o;
 
-#ifdef VERSION_SH
             if (o->collisionData == segmented_to_virtual(warp_pipe_seg3_collision_03009AC8)) {
                 play_sound(SOUND_MENU_ENTER_PIPE, m->marioObj->header.gfx.cameraToObject);
-                queue_rumble_data(15, 80);
-            } else {
+
+            }
+            else {
                 play_sound(SOUND_MENU_ENTER_HOLE, m->marioObj->header.gfx.cameraToObject);
-                queue_rumble_data(12, 80);
+
             }
-#else
-            play_sound(o->collisionData == segmented_to_virtual(warp_pipe_seg3_collision_03009AC8)
-                           ? SOUND_MENU_ENTER_PIPE
-                           : SOUND_MENU_ENTER_HOLE,
-                       m->marioObj->header.gfx.cameraToObject);
-#endif
 
             mario_stop_riding_object(m);
             return set_mario_action(m, ACT_DISAPPEARED, (WARP_OP_WARP_OBJECT << 16) + 2);
@@ -899,7 +961,7 @@ u32 interact_warp(struct MarioState *m, UNUSED u32 interactType, struct Object *
     return FALSE;
 }
 
-u32 interact_warp_door(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_warp_door(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 doorAction = 0;
     u32 saveFlags = save_file_get_flags();
     s16 warpDoorId = o->oBehParams >> 24;
@@ -941,7 +1003,8 @@ u32 interact_warp_door(struct MarioState *m, UNUSED u32 interactType, struct Obj
             if (doorAction == 0) {
                 if (actionArg & 0x00000001) {
                     doorAction = ACT_PULLING_DOOR;
-                } else {
+                }
+                else {
                     doorAction = ACT_PUSHING_DOOR;
                 }
             }
@@ -955,7 +1018,7 @@ u32 interact_warp_door(struct MarioState *m, UNUSED u32 interactType, struct Obj
     return FALSE;
 }
 
-u32 get_door_save_file_flag(struct Object *door) {
+u32 get_door_save_file_flag(struct Object* door) {
     u32 saveFileFlag = 0;
     s16 requiredNumStars = door->oBehParams >> 24;
 
@@ -963,39 +1026,41 @@ u32 get_door_save_file_flag(struct Object *door) {
     s16 isPssDoor = door->oPosY > 500.0f;
 
     switch (requiredNumStars) {
-        case 1:
-            if (isPssDoor) {
-                saveFileFlag = SAVE_FLAG_UNLOCKED_PSS_DOOR;
-            } else {
-                saveFileFlag = SAVE_FLAG_UNLOCKED_WF_DOOR;
-            }
-            break;
+    case 1:
+        if (isPssDoor) {
+            saveFileFlag = SAVE_FLAG_UNLOCKED_PSS_DOOR;
+        }
+        else {
+            saveFileFlag = SAVE_FLAG_UNLOCKED_WF_DOOR;
+        }
+        break;
 
-        case 3:
-            if (isCcmDoor) {
-                saveFileFlag = SAVE_FLAG_UNLOCKED_CCM_DOOR;
-            } else {
-                saveFileFlag = SAVE_FLAG_UNLOCKED_JRB_DOOR;
-            }
-            break;
+    case 3:
+        if (isCcmDoor) {
+            saveFileFlag = SAVE_FLAG_UNLOCKED_CCM_DOOR;
+        }
+        else {
+            saveFileFlag = SAVE_FLAG_UNLOCKED_JRB_DOOR;
+        }
+        break;
 
-        case 8:
-            saveFileFlag = SAVE_FLAG_UNLOCKED_BITDW_DOOR;
-            break;
+    case 8:
+        saveFileFlag = SAVE_FLAG_UNLOCKED_BITDW_DOOR;
+        break;
 
-        case 30:
-            saveFileFlag = SAVE_FLAG_UNLOCKED_BITFS_DOOR;
-            break;
+    case 30:
+        saveFileFlag = SAVE_FLAG_UNLOCKED_BITFS_DOOR;
+        break;
 
-        case 50:
-            saveFileFlag = SAVE_FLAG_UNLOCKED_50_STAR_DOOR;
-            break;
+    case 50:
+        saveFileFlag = SAVE_FLAG_UNLOCKED_50_STAR_DOOR;
+        break;
     }
 
     return saveFileFlag;
 }
 
-u32 interact_door(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_door(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     s16 requiredNumStars = o->oBehParams >> 24;
     s16 numStars = save_file_get_total_star_count(gCurrSaveFileNum - 1, COURSE_MIN - 1, COURSE_MAX - 1);
 
@@ -1007,7 +1072,8 @@ u32 interact_door(struct MarioState *m, UNUSED u32 interactType, struct Object *
 
             if (actionArg & 0x00000001) {
                 enterDoorAction = ACT_PULLING_DOOR;
-            } else {
+            }
+            else {
                 enterDoorAction = ACT_PUSHING_DOOR;
             }
 
@@ -1024,28 +1090,29 @@ u32 interact_door(struct MarioState *m, UNUSED u32 interactType, struct Object *
             }
 
             return set_mario_action(m, enterDoorAction, actionArg);
-        } else if (!sDisplayingDoorText) {
+        }
+        else if (!sDisplayingDoorText) {
             u32 text = DIALOG_022 << 16;
 
             switch (requiredNumStars) {
-                case 1:
-                    text = DIALOG_024 << 16;
-                    break;
-                case 3:
-                    text = DIALOG_025 << 16;
-                    break;
-                case 8:
-                    text = DIALOG_026 << 16;
-                    break;
-                case 30:
-                    text = DIALOG_027 << 16;
-                    break;
-                case 50:
-                    text = DIALOG_028 << 16;
-                    break;
-                case 70:
-                    text = DIALOG_029 << 16;
-                    break;
+            case 1:
+                text = DIALOG_024 << 16;
+                break;
+            case 3:
+                text = DIALOG_025 << 16;
+                break;
+            case 8:
+                text = DIALOG_026 << 16;
+                break;
+            case 30:
+                text = DIALOG_027 << 16;
+                break;
+            case 50:
+                text = DIALOG_028 << 16;
+                break;
+            case 70:
+                text = DIALOG_029 << 16;
+                break;
             }
 
             text += requiredNumStars - numStars;
@@ -1053,7 +1120,8 @@ u32 interact_door(struct MarioState *m, UNUSED u32 interactType, struct Object *
             sDisplayingDoorText = TRUE;
             return set_mario_action(m, ACT_READING_AUTOMATIC_DIALOG, text);
         }
-    } else if (m->action == ACT_IDLE && sDisplayingDoorText == TRUE && requiredNumStars == 70) {
+    }
+    else if (m->action == ACT_IDLE && sDisplayingDoorText == TRUE && requiredNumStars == 70) {
         m->interactObj = o;
         m->usedObj = o;
         return set_mario_action(m, ACT_ENTERING_STAR_DOOR, should_push_or_pull_door(m, o));
@@ -1062,7 +1130,7 @@ u32 interact_door(struct MarioState *m, UNUSED u32 interactType, struct Object *
     return FALSE;
 }
 
-u32 interact_cannon_base(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_cannon_base(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (m->action != ACT_IN_CANNON) {
         mario_stop_riding_and_holding(m);
         o->oInteractStatus = INT_STATUS_INTERACTED;
@@ -1074,7 +1142,7 @@ u32 interact_cannon_base(struct MarioState *m, UNUSED u32 interactType, struct O
     return FALSE;
 }
 
-u32 interact_igloo_barrier(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_igloo_barrier(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     //! Sets used object without changing action (LOTS of interesting glitches,
     // but unfortunately the igloo barrier is the only object with this interaction
     // type)
@@ -1084,8 +1152,8 @@ u32 interact_igloo_barrier(struct MarioState *m, UNUSED u32 interactType, struct
     return FALSE;
 }
 
-u32 interact_tornado(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
-    struct Object *marioObj = m->marioObj;
+u32 interact_tornado(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
+    struct Object* marioObj = m->marioObj;
 
     if (m->action != ACT_TORNADO_TWIRLING && m->action != ACT_SQUISHED) {
         mario_stop_riding_and_holding(m);
@@ -1100,17 +1168,16 @@ u32 interact_tornado(struct MarioState *m, UNUSED u32 interactType, struct Objec
         marioObj->oMarioTornadoPosY = m->pos[1] - o->oPosY;
 
         play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
-#ifdef VERSION_SH
-        queue_rumble_data(30, 60);
-#endif
+
+
         return set_mario_action(m, ACT_TORNADO_TWIRLING, m->action == ACT_TWIRLING);
     }
 
     return FALSE;
 }
 
-u32 interact_whirlpool(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
-    struct Object *marioObj = m->marioObj;
+u32 interact_whirlpool(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
+    struct Object* marioObj = m->marioObj;
 
     if (m->action != ACT_CAUGHT_IN_WHIRLPOOL) {
         mario_stop_riding_and_holding(m);
@@ -1123,17 +1190,16 @@ u32 interact_whirlpool(struct MarioState *m, UNUSED u32 interactType, struct Obj
         marioObj->oMarioWhirlpoolPosY = m->pos[1] - o->oPosY;
 
         play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
-#ifdef VERSION_SH
-        queue_rumble_data(30, 60);
-#endif
+
+
         return set_mario_action(m, ACT_CAUGHT_IN_WHIRLPOOL, 0);
     }
 
     return FALSE;
 }
 
-u32 interact_strong_wind(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
-    UNUSED struct Object *marioObj = m->marioObj;
+u32 interact_strong_wind(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
+    UNUSED struct Object* marioObj = m->marioObj;
 
     if (m->action != ACT_GETTING_BLOWN) {
         mario_stop_riding_and_holding(m);
@@ -1154,21 +1220,45 @@ u32 interact_strong_wind(struct MarioState *m, UNUSED u32 interactType, struct O
     return FALSE;
 }
 
-u32 interact_flame(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_flame(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 burningAction = ACT_BURNING_JUMP;
 
-    if (!sInvulnerable && !(m->flags & MARIO_METAL_CAP) && !(m->flags & MARIO_VANISH_CAP)
+    if (!sInvulnerable && !(m->flags & MARIO_METAL_CAP) && !(m->flags & MARIO_VANISH_CAP) && !(m->flags & MARIO_IS_SUPER)
         && !(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
+        if (!(m->flags & MARIO_IS_SUPER))
+        {
+            if (gDialogHealthSystem == SONIC_HEALTH)
+            {
+                if (gMarioState->numCoins > 0)
+                {
+                    if (gMarioState->numCoins >= 50) {
+                        play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                        obj_spawn_yellow_coins(m->marioObj, 50);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    }
+                    else {
+                        play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                        obj_spawn_yellow_coins(m->marioObj, gMarioState->numCoins);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    }
+                }
+                else
+                {
+                    m->health = 0xFF;
+                }
+            }
+        }
         o->oInteractStatus = INT_STATUS_INTERACTED;
         m->interactObj = o;
 
         if ((m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER))
             || m->waterLevel - m->pos[1] > 50.0f) {
             play_sound(SOUND_GENERAL_FLAME_OUT, m->marioObj->header.gfx.cameraToObject);
-        } else {
+        }
+        else {
             m->marioObj->oMarioBurnTimer = 0;
             update_mario_sound_and_camera(m);
             play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
@@ -1184,12 +1274,13 @@ u32 interact_flame(struct MarioState *m, UNUSED u32 interactType, struct Object
     return FALSE;
 }
 
-u32 interact_snufit_bullet(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_snufit_bullet(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)) {
-        if (m->flags & MARIO_METAL_CAP) {
+        if ((m->flags & MARIO_METAL_CAP) || (m->flags & MARIO_IS_SUPER)) {
             o->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED;
             play_sound(SOUND_ACTION_UNKNOWN458, m->marioObj->header.gfx.cameraToObject);
-        } else {
+        }
+        else {
             o->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_ATTACKED_MARIO;
             m->interactObj = o;
             take_damage_from_interact_object(m);
@@ -1198,49 +1289,53 @@ u32 interact_snufit_bullet(struct MarioState *m, UNUSED u32 interactType, struct
             update_mario_sound_and_camera(m);
 
             return drop_and_set_mario_action(m, determine_knockback_action(m, o->oDamageOrCoinValue),
-                                             o->oDamageOrCoinValue);
+                o->oDamageOrCoinValue);
         }
     }
 
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return FALSE;
 }
 
-u32 interact_clam_or_bubba(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_clam_or_bubba(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (o->oInteractionSubtype & INT_SUBTYPE_EATS_MARIO) {
         o->oInteractStatus = INT_STATUS_INTERACTED;
         m->interactObj = o;
         return set_mario_action(m, ACT_EATEN_BY_BUBBA, 0);
-    } else if (take_damage_and_knock_back(m, o)) {
+    }
+    else if (take_damage_and_knock_back(m, o)) {
         return TRUE;
     }
 
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return TRUE;
 }
 
-u32 interact_bully(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+
+
+
+u32 interact_bully(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     UNUSED u32 unused;
 
     u32 interaction;
-    if (m->flags & MARIO_METAL_CAP) {
+    if ((m->flags & MARIO_METAL_CAP) || (m->flags & MARIO_IS_SUPER) ) {
+
         interaction = INT_FAST_ATTACK_OR_SHELL;
-    } else {
+    }
+    else {
         interaction = determine_interaction(m, o);
     }
 
     m->interactObj = o;
+    m->homingObj = NULL;
+
 
     if (interaction & INT_ATTACK_NOT_FROM_BELOW) {
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
         push_mario_out_of_object(m, o, 5.0f);
 
         m->forwardVel = -16.0f;
@@ -1263,16 +1358,15 @@ u32 interact_bully(struct MarioState *m, UNUSED u32 interactType, struct Object
 
         push_mario_out_of_object(m, o, 5.0f);
         drop_and_set_mario_action(m, bully_knock_back_mario(m), 0);
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
+
         return TRUE;
     }
 
     return FALSE;
 }
 
-u32 interact_shock(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_shock(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
         && !(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         u32 actionArg = (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) == 0;
@@ -1282,13 +1376,12 @@ u32 interact_shock(struct MarioState *m, UNUSED u32 interactType, struct Object
 
         take_damage_from_interact_object(m);
         play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
-#ifdef VERSION_SH
-        queue_rumble_data(70, 60);
-#endif
+
 
         if (m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER)) {
             return drop_and_set_mario_action(m, ACT_WATER_SHOCKED, 0);
-        } else {
+        }
+        else {
             update_mario_sound_and_camera(m);
             return drop_and_set_mario_action(m, ACT_SHOCKED, actionArg);
         }
@@ -1297,18 +1390,17 @@ u32 interact_shock(struct MarioState *m, UNUSED u32 interactType, struct Object
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return FALSE;
 }
 
-static u32 interact_stub(UNUSED struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+static u32 interact_stub(UNUSED struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
     return FALSE;
 }
 
-u32 interact_mr_blizzard(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_mr_blizzard(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (take_damage_and_knock_back(m, o)) {
         return TRUE;
     }
@@ -1316,24 +1408,25 @@ u32 interact_mr_blizzard(struct MarioState *m, UNUSED u32 interactType, struct O
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return FALSE;
 }
 
-u32 interact_hit_from_below(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_hit_from_below(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     UNUSED u32 unused;
 
     u32 interaction;
-    if (m->flags & MARIO_METAL_CAP) {
+    if (((m->flags & MARIO_METAL_CAP) || (m->flags & MARIO_IS_SUPER)) && m->action != ACT_DIVE) {
+        if (m->action != ACT_DIVE )
+        { 
         interaction = INT_FAST_ATTACK_OR_SHELL;
-    } else {
+        }
+    }
+    else {
         interaction = determine_interaction(m, o);
     }
 
     if (interaction & INT_ANY_ATTACK) {
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
         attack_object(o, interaction);
         bounce_back_from_attack(m, interaction);
 
@@ -1349,33 +1442,39 @@ u32 interact_hit_from_below(struct MarioState *m, UNUSED u32 interactType, struc
                 play_sound(SOUND_MARIO_TWIRL_BOUNCE, m->marioObj->header.gfx.cameraToObject);
 #endif
                 return drop_and_set_mario_action(m, ACT_TWIRLING, 0);
-            } else {
+            }
+            else {
                 bounce_off_object(m, o, 30.0f);
             }
         }
-    } else if (take_damage_and_knock_back(m, o)) {
+    }
+    else if (take_damage_and_knock_back(m, o)) {
         return TRUE;
     }
 
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return FALSE;
 }
 
-u32 interact_bounce_top(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_bounce_top(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 interaction;
-    if (m->flags & MARIO_METAL_CAP) {
+    struct Object* goomba = o;
+    if (goomba->behavior == bhvGoomba)
+    {
+        m->interactObj = o;
+    }
+
+    if (((m->flags & MARIO_METAL_CAP) || (m->flags & MARIO_IS_SUPER)) && m->action != ACT_DIVE) {
         interaction = INT_FAST_ATTACK_OR_SHELL;
-    } else {
+    }
+    else {
         interaction = determine_interaction(m, o);
     }
 
     if (interaction & INT_ATTACK_NOT_FROM_BELOW) {
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
         attack_object(o, interaction);
         bounce_back_from_attack(m, interaction);
 
@@ -1387,39 +1486,40 @@ u32 interact_bounce_top(struct MarioState *m, UNUSED u32 interactType, struct Ob
                 play_sound(SOUND_MARIO_TWIRL_BOUNCE, m->marioObj->header.gfx.cameraToObject);
 #endif
                 return drop_and_set_mario_action(m, ACT_TWIRLING, 0);
-            } else {
+            }
+            else {
                 bounce_off_object(m, o, 30.0f);
             }
         }
-    } else if (take_damage_and_knock_back(m, o)) {
+    }
+    else if (take_damage_and_knock_back(m, o)) {
         return TRUE;
     }
 
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return FALSE;
 }
 
-u32 interact_unknown_08(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_unknown_08(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 interaction = determine_interaction(m, o);
 
     if (interaction & INT_PUNCH) {
         o->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED | ATTACK_PUNCH;
         bounce_back_from_attack(m, interaction);
-    } else if (take_damage_and_knock_back(m, o)) {
+    }
+    else if (take_damage_and_knock_back(m, o)) {
         return TRUE;
     }
 
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return FALSE;
 }
 
-u32 interact_damage(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_damage(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (take_damage_and_knock_back(m, o)) {
         return TRUE;
     }
@@ -1427,20 +1527,27 @@ u32 interact_damage(struct MarioState *m, UNUSED u32 interactType, struct Object
     if (!(o->oInteractionSubtype & INT_SUBTYPE_DELAY_INVINCIBILITY)) {
         sDelayInvincTimer = TRUE;
     }
-
     return FALSE;
 }
 
-u32 interact_breakable(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
-    u32 interaction = determine_interaction(m, o);
+u32 interact_breakable(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
+    void* script = virtual_to_segmented(0x13, o->behavior);
 
-    if (interaction & INT_ATTACK_NOT_WEAK_FROM_ABOVE) {
-        attack_object(o, interaction);
-        bounce_back_from_attack(m, interaction);
+        u32 interaction = determine_interaction(m, o);
+        if (m->forwardVel >= 19.0f)
+        { 
+        if (gMarioState->action == ACT_SLIDE_KICK_SLIDE || gMarioState->action == ACT_SLIDE_KICK)
+        {
+            o->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED;
+        }
+        }
+        if (interaction & INT_ATTACK_NOT_WEAK_FROM_ABOVE) {
+            attack_object(o, interaction);
+            bounce_back_from_attack(m, interaction);
 
-        m->interactObj = o;
+            m->interactObj = o;
 
-        switch (interaction) {
+            switch (interaction) {
             case INT_HIT_FROM_ABOVE:
                 bounce_off_object(m, o, 30.0f); //! Not in the 0x8F mask
                 break;
@@ -1448,15 +1555,18 @@ u32 interact_breakable(struct MarioState *m, UNUSED u32 interactType, struct Obj
             case INT_HIT_FROM_BELOW:
                 hit_object_from_below(m, o);
                 break;
-        }
 
-        return TRUE;
-    }
+            }
 
-    return FALSE;
+            return TRUE;
+
+        }
+
+        return FALSE;
+    
 }
 
-u32 interact_koopa_shell(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_koopa_shell(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if (!(m->action & ACT_FLAG_RIDING_SHELL)) {
         u32 interaction = determine_interaction(m, o);
 
@@ -1482,7 +1592,7 @@ u32 interact_koopa_shell(struct MarioState *m, UNUSED u32 interactType, struct O
     return FALSE;
 }
 
-u32 check_object_grab_mario(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 check_object_grab_mario(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     if ((!(m->action & (ACT_FLAG_AIR | ACT_FLAG_INVULNERABLE | ACT_FLAG_ATTACKING)) || !sInvulnerable)
         && (o->oInteractionSubtype & INT_SUBTYPE_GRABS_MARIO)) {
         if (object_facing_mario(m, o, 0x2AAA)) {
@@ -1495,9 +1605,7 @@ u32 check_object_grab_mario(struct MarioState *m, UNUSED u32 interactType, struc
 
             update_mario_sound_and_camera(m);
             play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
-#ifdef VERSION_SH
-            queue_rumble_data(5, 80);
-#endif
+
             return set_mario_action(m, ACT_GRABBED, 0);
         }
     }
@@ -1506,17 +1614,17 @@ u32 check_object_grab_mario(struct MarioState *m, UNUSED u32 interactType, struc
     return FALSE;
 }
 
-u32 interact_pole(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_pole(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     s32 actionId = m->action & ACT_ID_MASK;
     if (actionId >= 0x080 && actionId < 0x0A0) {
         if (!(m->prevAction & ACT_FLAG_ON_POLE) || m->usedObj != o) {
 #ifdef VERSION_SH
             f32 velConv = m->forwardVel; // conserve the velocity.
-            struct Object *marioObj = m->marioObj;
+            struct Object* marioObj = m->marioObj;
             u32 lowSpeed;
 #else
             u32 lowSpeed = (m->forwardVel <= 10.0f);
-            struct Object *marioObj = m->marioObj;
+            struct Object* marioObj = m->marioObj;
 #endif
 
             mario_stop_riding_and_holding(m);
@@ -1546,9 +1654,7 @@ u32 interact_pole(struct MarioState *m, UNUSED u32 interactType, struct Object *
             marioObj->oMarioPoleYawVel = (s32)(m->forwardVel * 0x100 + 0x1000);
 #endif
             reset_mario_pitch(m);
-#ifdef VERSION_SH
-            queue_rumble_data(5, 80);
-#endif
+
             return set_mario_action(m, ACT_GRAB_POLE_FAST, 0);
         }
     }
@@ -1556,7 +1662,7 @@ u32 interact_pole(struct MarioState *m, UNUSED u32 interactType, struct Object *
     return FALSE;
 }
 
-u32 interact_hoot(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_hoot(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     s32 actionId = m->action & ACT_ID_MASK;
 
     //! Can pause to advance the global timer without falling too far, allowing
@@ -1568,9 +1674,7 @@ u32 interact_hoot(struct MarioState *m, UNUSED u32 interactType, struct Object *
         m->interactObj = o;
         m->usedObj = o;
 
-#ifdef VERSION_SH
-        queue_rumble_data(5, 80);
-#endif
+
         update_mario_sound_and_camera(m);
         return set_mario_action(m, ACT_RIDING_HOOT, 0);
     }
@@ -1578,7 +1682,7 @@ u32 interact_hoot(struct MarioState *m, UNUSED u32 interactType, struct Object *
     return FALSE;
 }
 
-u32 interact_cap(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_cap(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 capFlag = get_mario_cap_flag(o);
     u16 capMusic = 0;
     u16 capTime = 0;
@@ -1587,24 +1691,24 @@ u32 interact_cap(struct MarioState *m, UNUSED u32 interactType, struct Object *o
         m->interactObj = o;
         o->oInteractStatus = INT_STATUS_INTERACTED;
 
-        m->flags &= ~MARIO_CAP_ON_HEAD & ~MARIO_CAP_IN_HAND;
+        //m->flags &= ~MARIO_CAP_ON_HEAD & ~MARIO_CAP_IN_HAND;
         m->flags |= capFlag;
 
         switch (capFlag) {
-            case MARIO_VANISH_CAP:
-                capTime = 600;
-                capMusic = SEQUENCE_ARGS(4, SEQ_EVENT_POWERUP);
-                break;
+        case MARIO_VANISH_CAP:
+            capTime = 600;
+            capMusic = SEQUENCE_ARGS(4, SEQ_EVENT_POWERUP);
+            break;
 
-            case MARIO_METAL_CAP:
-                capTime = 600;
-                capMusic = SEQUENCE_ARGS(4, SEQ_EVENT_METAL_CAP);
-                break;
+        case MARIO_METAL_CAP:
+            capTime = 600;
+            capMusic = SEQUENCE_ARGS(4, SEQ_EVENT_METAL_CAP);
+            break;
 
-            case MARIO_WING_CAP:
-                capTime = 1800;
-                capMusic = SEQUENCE_ARGS(4, SEQ_EVENT_POWERUP);
-                break;
+        case MARIO_WING_CAP:
+            capTime = 1800;
+            capMusic = SEQUENCE_ARGS(4, SEQ_EVENT_POWERUP);
+            break;
         }
 
         if (capTime > m->capTimer) {
@@ -1612,9 +1716,10 @@ u32 interact_cap(struct MarioState *m, UNUSED u32 interactType, struct Object *o
         }
 
         if ((m->action & ACT_FLAG_IDLE) || m->action == ACT_WALKING) {
-            m->flags |= MARIO_CAP_IN_HAND;
+            
             set_mario_action(m, ACT_PUTTING_ON_CAP, 0);
-        } else {
+        }
+        else {
             m->flags |= MARIO_CAP_ON_HEAD;
         }
 
@@ -1622,7 +1727,10 @@ u32 interact_cap(struct MarioState *m, UNUSED u32 interactType, struct Object *o
         play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
 
         if (capMusic != 0) {
-            play_cap_music(capMusic);
+            if (!(m->flags & MARIO_IS_SUPER))
+            {
+                play_cap_music(capMusic);
+            }
         }
 
         return TRUE;
@@ -1631,8 +1739,8 @@ u32 interact_cap(struct MarioState *m, UNUSED u32 interactType, struct Object *o
     return FALSE;
 }
 
-u32 interact_grabbable(struct MarioState *m, u32 interactType, struct Object *o) {
-    const BehaviorScript *script = virtual_to_segmented(0x13, o->behavior);
+u32 interact_grabbable(struct MarioState* m, u32 interactType, struct Object* o) {
+    void* script = virtual_to_segmented(0x13, o->behavior);
 
     if (o->oInteractionSubtype & INT_SUBTYPE_KICKABLE) {
         u32 interaction = determine_interaction(m, o);
@@ -1660,11 +1768,10 @@ u32 interact_grabbable(struct MarioState *m, u32 interactType, struct Object *o)
     if (script != bhvBowser) {
         push_mario_out_of_object(m, o, -5.0f);
     }
-
     return FALSE;
 }
 
-u32 mario_can_talk(struct MarioState *m, u32 arg) {
+u32 mario_can_talk(struct MarioState* m, u32 arg) {
     s16 val6;
 
     if ((m->action & ACT_FLAG_IDLE) != 0x00000000) {
@@ -1698,7 +1805,7 @@ u32 mario_can_talk(struct MarioState *m, u32 arg) {
 #define SIGN_RANGE 0x4000
 #endif
 
-u32 check_read_sign(struct MarioState *m, struct Object *o) {
+u32 check_read_sign(struct MarioState* m, struct Object* o) {
     if ((m->input & READ_MASK) && mario_can_talk(m, 0) && object_facing_mario(m, o, SIGN_RANGE)) {
         s16 facingDYaw = (s16)(o->oMoveAngleYaw + 0x8000) - m->faceAngle[1];
         if (facingDYaw >= -SIGN_RANGE && facingDYaw <= SIGN_RANGE) {
@@ -1718,7 +1825,7 @@ u32 check_read_sign(struct MarioState *m, struct Object *o) {
     return FALSE;
 }
 
-u32 check_npc_talk(struct MarioState *m, struct Object *o) {
+u32 check_npc_talk(struct MarioState* m, struct Object* o) {
     if ((m->input & READ_MASK) && mario_can_talk(m, 1)) {
         s16 facingDYaw = mario_obj_angle_to_object(m, o) - m->faceAngle[1];
         if (facingDYaw >= -0x4000 && facingDYaw <= 0x4000) {
@@ -1736,21 +1843,24 @@ u32 check_npc_talk(struct MarioState *m, struct Object *o) {
     return FALSE;
 }
 
-u32 interact_text(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
+u32 interact_text(struct MarioState* m, UNUSED u32 interactType, struct Object* o) {
     u32 interact = FALSE;
 
     if (o->oInteractionSubtype & INT_SUBTYPE_SIGN) {
         interact = check_read_sign(m, o);
-    } else if (o->oInteractionSubtype & INT_SUBTYPE_NPC) {
+    }
+    else if (o->oInteractionSubtype & INT_SUBTYPE_NPC) {
         interact = check_npc_talk(m, o);
-    } else {
+    }
+    else {
         push_mario_out_of_object(m, o, 2.0f);
     }
 
     return interact;
 }
 
-void check_kick_or_punch_wall(struct MarioState *m) {
+void check_kick_or_punch_wall(struct MarioState* m) {
+
     if (m->flags & (MARIO_PUNCHING | MARIO_KICKING | MARIO_TRIPPING)) {
         Vec3f detector;
         detector[0] = m->pos[0] + 50.0f * sins(m->faceAngle[1]);
@@ -1766,7 +1876,8 @@ void check_kick_or_punch_wall(struct MarioState *m) {
                 mario_set_forward_vel(m, -48.0f);
                 play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
                 m->particleFlags |= PARTICLE_TRIANGLE;
-            } else if (m->action & ACT_FLAG_AIR) {
+            }
+            else if (m->action & ACT_FLAG_AIR) {
                 mario_set_forward_vel(m, -16.0f);
                 play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
                 m->particleFlags |= PARTICLE_TRIANGLE;
@@ -1775,7 +1886,7 @@ void check_kick_or_punch_wall(struct MarioState *m) {
     }
 }
 
-void mario_process_interactions(struct MarioState *m) {
+void mario_process_interactions(struct MarioState* m) {
     sDelayInvincTimer = FALSE;
     sInvulnerable = (m->action & ACT_FLAG_INVULNERABLE) || m->invincTimer != 0;
 
@@ -1784,7 +1895,7 @@ void mario_process_interactions(struct MarioState *m) {
         for (i = 0; i < 31; i++) {
             u32 interactType = sInteractionHandlers[i].interactType;
             if (m->collidedObjInteractTypes & interactType) {
-                struct Object *object = mario_get_collided_object(m, interactType);
+                struct Object* object = mario_get_collided_object(m, interactType);
 
                 m->collidedObjInteractTypes &= ~interactType;
 
@@ -1814,7 +1925,7 @@ void mario_process_interactions(struct MarioState *m) {
     }
 }
 
-void check_death_barrier(struct MarioState *m) {
+void check_death_barrier(struct MarioState* m) {
     if (m->pos[1] < m->floorHeight + 2048.0f) {
         if (level_trigger_warp(m, WARP_OP_WARP_FLOOR) == 20 && !(m->flags & MARIO_UNKNOWN_18)) {
             play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
@@ -1822,18 +1933,48 @@ void check_death_barrier(struct MarioState *m) {
     }
 }
 
-void check_lava_boost(struct MarioState *m) {
+void check_lava_boost(struct MarioState* m) {
+    if (!(m->flags & MARIO_IS_SUPER))
+    {
     if (!(m->action & ACT_FLAG_RIDING_SHELL) && m->pos[1] < m->floorHeight + 10.0f) {
-        if (!(m->flags & MARIO_METAL_CAP)) {
-            m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
-        }
+        
+            if (gDialogHealthSystem != SONIC_HEALTH)
+            {
+
+                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
+
+            }
+            else
+            {
+                if (gMarioState->numCoins > 0)
+                {
+                    if (gMarioState->numCoins >= 50) {
+                        play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                        obj_spawn_yellow_coins(m->marioObj, 50);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    }
+                    else {
+                        play_sound(SOUND_GENERAL_RINGLOSS, gGlobalSoundSource);
+                        obj_spawn_yellow_coins(m->marioObj, gMarioState->numCoins);
+                        gMarioState->numCoins = 0;
+                        gHudDisplay.coins = 0;
+                    }
+                }
+                else
+                {
+                    m->health = 0xFF;
+                }
+            }
+        
 
         update_mario_sound_and_camera(m);
         drop_and_set_mario_action(m, ACT_LAVA_BOOST, 0);
     }
+    }
 }
 
-void pss_begin_slide(UNUSED struct MarioState *m) {
+void pss_begin_slide(UNUSED struct MarioState* m) {
     if (!(gHudDisplay.flags & HUD_DISPLAY_FLAG_TIMER)) {
         level_control_timer(TIMER_CONTROL_SHOW);
         level_control_timer(TIMER_CONTROL_START);
@@ -1841,7 +1982,7 @@ void pss_begin_slide(UNUSED struct MarioState *m) {
     }
 }
 
-void pss_end_slide(struct MarioState *m) {
+void pss_end_slide(struct MarioState* m) {
     //! This flag isn't set on death or level entry, allowing double star spawn
     if (sPssSlideStarted) {
         u16 slideTime = level_control_timer(TIMER_CONTROL_STOP);
@@ -1853,7 +1994,7 @@ void pss_end_slide(struct MarioState *m) {
     }
 }
 
-void mario_handle_special_floors(struct MarioState *m) {
+void mario_handle_special_floors(struct MarioState* m) {
     if ((m->action & ACT_GROUP_MASK) == ACT_GROUP_CUTSCENE) {
         return;
     }
